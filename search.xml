<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>激光的帧间匹配</title>
      <link href="/2025/01/02/%E6%BF%80%E5%85%89%E5%B8%A7%E9%97%B4%E5%8C%B9%E9%85%8D/"/>
      <url>/2025/01/02/%E6%BF%80%E5%85%89%E5%B8%A7%E9%97%B4%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h1>激光的帧间匹配</h1><h2 id="ICP-匹配方法">ICP 匹配方法</h2><p>具体数学描述和求解方法请看 <a href="https://hins-h.github.io/2024/12/20/%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BE%E8%BF%90%E5%8A%A8%E7%95%B8%E5%8F%98%E5%8E%BB%E9%99%A4">激光雷达运动畸变去除</a>。这里主要添加求解方法的证明。<br>$$<br>\begin{align}<br>E(R,t)=\frac{1}{N_p}\sum_{i=1}<sup>{N_p}||x_i-Rp_i-t||</sup>2\<br>E(R,t)&amp;=\frac{1}{N_p}\sum_{i=1}<sup>{N_p}||x_i-Rp_i-t-u_x+Ru_p+u_x-Ru_p||</sup>2\<br>&amp;=\frac{1}{N_p}\sum_{i=1}<sup>{N_p}||x_i-u_x-R(p_i-u_p)+(u_x-Ru_p-t)||</sup>2\<br>&amp;=\frac{1}{N_p}\sum_{i=1}<sup>{N_p}||x_i-u_x-R(p_i-u_p)||</sup>2+||u_x-Ru_p-t||<sup>2+2(x_i-u_x-R(p_i-u_p))</sup>T(u_x-Ru_p-t)\<br>&amp;=\frac{1}{N_p}\sum_{i=1}<sup>{N_p}||x_i-u_x-R(p_i-u_p)||</sup>2+||u_x-Ru_p-t||^2\<br>\end{align}<br>$$</p><p>其中 $||x_i-u_x-R(p_i-u_p)||^2$ 只和 $R$ 有关，当已知 $R$ 时可以通过 $u_x-Ru_p-t=0$ 求解出 $t$。故转换为最小化函数：</p><p>$$<br>\begin{align}<br>E(R,t)&amp;=\frac{1}{N_p}\sum_{i=1}<sup>{N_p}||x_i-u_x-R(p_i-u_p)||</sup>2\<br>&amp;=\frac{1}{N_p}\sum_{i=1}<sup>{N_p}||x_i</sup>{‘}-Rp_i<sup>{'}||</sup>2\<br>&amp;=\frac{1}{N_p}\sum_{i=1}<sup>{N_p}{x_i</sup>{’}}<sup>Tx_i</sup>{‘}+{p_i<sup>{'}}</sup>TR<sup>TRp_i</sup>{’}-2{x_i<sup>{'}}</sup>TRp_i^{'}\<br>\end{align}<br>$$</p><p>其中 ${x_i<sup>{'}}</sup>Tx_i^{‘}$ 和变量无关，是常数值，而 $R$ 是正交矩阵，$R<sup>TR=I$，${p_i</sup>{’}}<sup>TR</sup>TRp_i<sup>{'}={p_i</sup>{‘}}<sup>Tp_i</sup>{’}$，也是常数值，因此求 $E(R,t)$ 最小值最后可以转化为求 ${x_i<sup>{'}}</sup>TRp_i^{'}$ 的最大值。</p><p>$$<br>\sum_{i=1}<sup>{N_p}{x_i</sup>{‘}}<sup>TRp_i</sup>{’}=\sum_{i=1}<sup>{N_p}Trace(Rx_i</sup>{‘}{p_i<sup>{'}}</sup>T)=Trace(RH)<br>\H=\sum_{i=1}<sup>{N_p}x_i</sup>{’}{p_i<sup>{'}}</sup>T<br>$$</p><ul class="lvl-0"><li class="lvl-2"><p>定理：假设矩阵 A 为正定对称矩阵，则对于任意的正交矩阵 B，都有：$Trace(A)≥Trace(BA)$。</p></li></ul><p>$$<br>H=U\Lambda V^T\<br>X=VU^T —— 正交矩阵\<br>XH=VU^TU\Lambda V^T=V\Lambda V^T  —— 正定对称\<br>\Rightarrow Trace(XH) ≥ Trace(BXH)\<br>\Rightarrow R=X=VU^T<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> SLAM 学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>激光雷达运动畸变去除</title>
      <link href="/2024/12/20/%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BE%E8%BF%90%E5%8A%A8%E7%95%B8%E5%8F%98%E5%8E%BB%E9%99%A4/"/>
      <url>/2024/12/20/%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BE%E8%BF%90%E5%8A%A8%E7%95%B8%E5%8F%98%E5%8E%BB%E9%99%A4/</url>
      
        <content type="html"><![CDATA[<h1>激光雷达运动畸变去除</h1><h2 id="纯估计方法">纯估计方法</h2><h3 id="ICP-方法">ICP 方法</h3><h4 id="数学描述">数学描述</h4><p>给定两个点云集合：<br>$$<br>X={x_1,x_2, \cdots, x_{N_x} } \<br>P={p_1,p_2, \cdots, x_{N_p} }<br>$$</p><p>求解 $R$ 和 $t$ ，使得下式最小：</p><p>$$<br>E(R,t)=\frac{1}{N_p}\sum_{i=1}^{N_p} || x_i-Rp_i-t||^2<br>$$</p><h4 id="已知对应点的求解方法">已知对应点的求解方法</h4><p><img src="https://pic1.imgdb.cn/item/67b1ade2d0e0a243d4ffcf05.png" alt=""></p><p>则 ICP 的解为：<br>$$<br>R=UV^T \<br>t=u_x-Ru_p<br>$$<br>如下图所示，左边为两个点云集合，已知对应点，通过 ICP 求解后得到右边的匹配点云。</p><img src="https://pic1.imgdb.cn/item/67b1ae18d0e0a243d4ffcf0c.png" style="zoom: 67%;" /><h4 id="未知对应点的求解方法">未知对应点的求解方法</h4><p>实际中，我们一般不知道对应点的匹配，不能一步到位计算出 $R$ 和 $t$，需要进行迭代计算。</p><p>算法流程：</p><ul class="lvl-0"><li class="lvl-2"><p>寻找对应点</p></li><li class="lvl-2"><p>根据对应点，计算  $R$ 和 $t$</p></li><li class="lvl-2"><p>对点云进行转换，计算误差</p></li><li class="lvl-2"><p>不断迭代，直到误差小于某个值</p></li></ul><p><img src="https://pic1.imgdb.cn/item/67b1af21d0e0a243d4ffcf3a.png" alt=""></p><h4 id="ICP-方法在激光匹配中的缺点">ICP 方法在激光匹配中的缺点</h4><ul class="lvl-0"><li class="lvl-2"><p>没有考虑激光的运动畸变</p></li><li class="lvl-2"><p>当前的激光数据是错误的，如图中蓝色的点云就是有运动畸变的错误点云</p></li></ul><img src="https://pic1.imgdb.cn/item/67b1b1bbd0e0a243d4ffcfa5.png" style="zoom:50%;" /><h3 id="VICP-方法">VICP 方法</h3><p>VICP（Velocity Updating Iterative Closest Point Algorithm），ICP 算法的变种，考虑了机器人的运动，假设机器人是匀速运动，进行匹配的同时估计机器人的速度。</p><h4 id="数学表示">数学表示</h4><p>$X<sup>i,X</sup>{i-1}$ 表示第 $i$ 帧和第 $i-1$ 帧数据</p><p>$T_i,T_{i-1}$ 表示对应的位姿矩阵</p><p>机器人速度： $V_i=\frac{1}{\Delta t}T_{i-1}^{-1}T_i$</p><p>设第 $i$ 帧的时刻表：$(t_i-n\Delta t,t_i-(n-1)\Delta t,\cdots,t_i-\Delta t,t_i)$</p><p>则第 $i$ 帧第 $j$ 个节点的位姿矩阵为：$T(t_i-(n-j)\Delta t)=T_ie^{(n-j)\Delta t(-V_i)}$</p><p>可得矫正过程为：$\bar{X}^i = { e^{(n-j)\Delta t(-V_i)} x_j \mid j = 0, \cdots, n }$</p><h4 id="VICP算法流程">VICP算法流程</h4><img src="https://pic1.imgdb.cn/item/67b1b4b9d0e0a243d4ffd146.png" style="zoom:50%;" /><h4 id="矫正效果">矫正效果</h4><img src="https://pic1.imgdb.cn/item/67b1b4d0d0e0a243d4ffd159.png" style="zoom:50%;" /><h4 id="VICP方法的缺点">VICP方法的缺点</h4><ul class="lvl-0"><li class="lvl-2"><p>低帧率激光（5Hz），匀速运动假设不成立</p></li><li class="lvl-2"><p>数据预处理和状态估计过程耦合</p></li></ul><h2 id="里程计辅助方法">里程计辅助方法</h2><h3 id="传感器辅助运动畸变去除">传感器辅助运动畸变去除</h3><h4 id="IMU">IMU</h4><ul class="lvl-0"><li class="lvl-2"><p>直接测量角速度和线加速度</p></li><li class="lvl-2"><p>具有较高的角速度测量精度</p></li><li class="lvl-2"><p>测量频率极高（1kHz ~ 8kHz）</p></li><li class="lvl-2"><p>线加速度精度太差，二次积分在局部的精度依然很差</p></li></ul><h4 id="轮式里程计">轮式里程计</h4><ul class="lvl-0"><li class="lvl-2"><p>直接测量机器人的位移和角度</p></li><li class="lvl-2"><p>具有较高的局部角度测量精度</p></li><li class="lvl-2"><p>具有较高的局部位置测量精度</p></li><li class="lvl-2"><p>更新速度较高（100Hz ~ 200Hz）</p></li></ul><h3 id="轮式里程计辅助">轮式里程计辅助</h3><h4 id="已知数据">已知数据</h4><ul class="lvl-0"><li class="lvl-2"><p>已知当前帧雷达的起始时间 $t_s,t_e$</p></li><li class="lvl-2"><p>两个激光束间的时间 $\Delta t$</p></li><li class="lvl-2"><p>里程计数据按照时间顺序存储在一个队列中，队首的时间最早</p></li><li class="lvl-2"><p>最早的里程计数据的时间戳 &lt; $t_s$</p></li><li class="lvl-2"><p>最晚的里程计数据的时间戳 &gt; $t_e$</p></li></ul><h4 id="目标">目标</h4><ul class="lvl-0"><li class="lvl-2"><p>求解当前帧激光数据中每一个激光点对应的机器人位姿，即求解 ${ t_s,t_{s+\Delta t},\cdots,t_e }$ 时刻的机器人位姿</p></li><li class="lvl-2"><p>根据求解的位姿把所有激光点转换到同一坐标系下</p></li><li class="lvl-2"><p>重新封装成一帧激光数据，发布出去</p></li></ul><h4 id="求解-ts-te-时刻的位姿-ps-pe">求解 ts,te 时刻的位姿 ps,pe</h4><ul class="lvl-0"><li class="lvl-2"><p>里程计队列中正好和激光数据同步，假设第 $i$ 和第 $j$ 个数据时刻分别是 $t_s,t_e$ （这种情况发生的概率约等于0~）：</p></li></ul><p>$$<br>p_s={OdomList}[i]\<br>p_e={OdomList}[j]<br>$$</p><ul class="lvl-0"><li class="lvl-2"><p>在 $t_s$ 时刻没有对应的里程计位姿，则进行线性插值，设在 $l,k$ 时刻有位姿，且 $l&lt;s&lt;k$，则：<br>$$<br>p_l=OdomList[l]\<br>p_k=OdomList[k]\<br>p_s=\text{LinearInterp}(p_l,p_k,\frac{s-l}{k-l})<br>$$</p></li></ul><h4 id="二次插值">二次插值</h4><ul class="lvl-0"><li class="lvl-2"><p>在一帧激光数据之间，认为机器人做匀加速运动</p></li><li class="lvl-2"><p>机器人的位姿是关于时间 $t$ 的二次函数</p></li><li class="lvl-2"><p>设 $t_m=\frac{t_s+t_e}{2}$，且 $l&lt;m&lt;k$ 则：</p></li></ul><p>$$<br>p_m=\text{LinearInterp}(p_l,p_k,\frac{m-l}{k-l})<br>$$</p><ul class="lvl-0"><li class="lvl-2"><p>已知 $p_s,p_m,p_e$，可以插值一条二次曲线</p></li></ul><p>$$<br>P(t)=At^2+Bt+C\<br>t_s ≤ t ≤ t_e<br>$$</p><h4 id="二次曲线的近似">二次曲线的近似</h4><ul class="lvl-0"><li class="lvl-2"><p>用分段线性函数对二次曲线进行近似</p></li><li class="lvl-2"><p>分段数大于3时，近似误差可以忽略不计</p></li><li class="lvl-2"><p>在 $t_s$ 和 $t_e$ 时间段内，一共取 k 个位姿 ${p_s,p_{s+1},\cdots,p_{s+k-2},p_{e}}$</p></li><li class="lvl-2"><p>位姿通过线性插值获取，在这 k 个位姿之间，进行线性插值：</p></li></ul><p>$$<br>设 p_s 和 p_{s+1}之间有n个位姿{p_s,p_{s1},\cdots,p_{s(n-2)},p_{s+1}}，则：<br>p_{si}=\text{LinearInterp}(p_l,p_k,\frac{si-s}{\Delta t})<br>$$</p><h4 id="坐标系统-激光数据发布">坐标系统 - 激光数据发布</h4><ul class="lvl-0"><li class="lvl-2"><p>一帧激光数据 n 个激光点，每个激光点对应的位姿 ${p_1,p_2,\cdots,p_n}$ 通过上面的方法插值得到</p></li><li class="lvl-2"><p>$x_i$ 为转化之前的坐标，$x_i^{'}$ 为转化之后的坐标，则：</p></li></ul><p>$$<br>x_i<sup>{'}=p_i</sup>Tx_i<br>$$</p><ul class="lvl-0"><li class="lvl-2"><p>把转化之后的坐标转化为激光数据发出去：</p></li></ul><p><img src="https://pic1.imgdb.cn/item/67b22713d0e0a243d4ffeacc.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> SLAM 学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ORB-SLAM2 系统框架</title>
      <link href="/2024/12/10/ORB-SLAM2%20%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6/"/>
      <url>/2024/12/10/ORB-SLAM2%20%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1>ORB-SLAM2 系统框架</h1><p>ORB-SLAM 为纯单目系统，而 ORB-SLAM2 在单目系统上添加了双目和 RGB-D 的支持，所以系统框架需要分两部分来看，如下面两图所示。纯单目系统框架非常清晰，由追踪、局部建图和闭环 3 个主要线程构成，除此之外还包括地图初始化、位置识别、地图结构等模块。双目和 RGB-D 系统架构，相比于单目系统，只是添加了输入预处理模块用于处理双目和 RGB-D 数据，闭环检测由计算 Sim3 换成了 SE3（因为双目系统中尺度不确定性消失了），并增加了第 4 个线程 —— 全局 BA 优化。</p><p>下面就单目系统原理展开。</p><img src="https://pic1.imgdb.cn/item/678bcd4bd0e0a243d4f58278.jpg" alt="单目系统" style="zoom:50%;" /><img src="https://pic1.imgdb.cn/item/678bcd74d0e0a243d4f5827c.jpg" alt="双目系统" style="zoom:50%;" /><h2 id="地图结构">地图结构</h2><p>单目系统的地图结构如下图所示，由关键帧、地图点、共视关系图和生成树构成。</p><img src="https://pic1.imgdb.cn/item/678bce82d0e0a243d4f5828b.jpg" alt="地图结构" style="zoom:50%;" /><p>关键帧中的每个帧都包含丰富的属性，比如该帧对应相机在世界坐标系下的位姿坐标、ORB 特征点以及各种约束关系。约束关系是构建 BA 优化的关键，首先是关键帧之间的特征匹配关系能直接三角化重建出地图点，即 2D-2D 模型；其次是关键帧位姿、图像特征点和地图点构成的投影关系，通过最小化重投影误差来 BA 优化关键帧位姿和地图点，即 3D-2D 模型；最后，两个关键帧能同时观测到一些共同的地图点，这就构成了共视关系，即 3D-3D 模型。</p><p>以上所述的约束关系，都是关键帧之间通过图像特征点或者地图点间接建立的。为了方便，依据关键帧之间共视地图点的数量，在关键帧之间建立直接的约束关系（连接权重），共视点越多，连接权重越高。以关键帧为节点，关键帧之间的连接权重为边，所构建出来的图就是共视关系图。借助共视关系图，能迅速找出当前关键帧所在局部地图中的其他关键帧和地图点，从而进行局部 BA 优化。如下图所示。</p><img src="https://pic1.imgdb.cn/item/678bd243d0e0a243d4f58360.png" style="zoom:80%;" /><p>但是在闭环检测成功进入全局 BA 优化时，如果仍然在具有如此多约束边的共视关系图上进行，计算量会非常大。需要对共视关系图进行精简，具体策略是先将所有节点提取出来，每个节点只保留一个向前的边连接父节点和一个向后的边连接子节点，也就是生成树，用于构建闭环回路，在生成树的基础上，保留共视关系图中权重高的边，就得到了本征图，用于全局 BA 优化。</p><p>其实，整个算法运行过程就是在动态地维护该地图结构。</p><h2 id="地图初始化">地图初始化</h2><p>系统启动后，必须要先有一些地图初始云点，在这些初始云点的基础上才能往下不断增量建图。单目系统的地图初始化过程中，通过计算选取的两帧图像之间的相机位姿变换关系，以三角化重建地图初始云点，方法有很多：</p><ul class="lvl-0"><li class="lvl-2"><p>方法1：追踪环境中的某个已知物体（比如棋盘标定板）</p></li><li class="lvl-2"><p>方法2：追踪环境中某个平面上的一些点</p></li><li class="lvl-2"><p>方法3：追踪环境中非平面的一些点</p></li></ul><p>方法1需要依赖外界信息，灵活性较差。该系统的地图初始化过程，结合方法 2 和 3，并采用了一种基于统计的模型选择策略，智能地选择更好的一个作为最终结果。地图初始化具体流程如下图所示。</p><img src="https://pic1.imgdb.cn/item/678be45ad0e0a243d4f587e6.jpg" alt="地图初始化" style="zoom:67%;" /><h2 id="位置识别">位置识别</h2><p>如果 SLAM 建图过程中追踪线程突然跟丢了，此时就要启动重定位尽快找回跟丢的位置信息；或者 SLAM 在构建很大的地图后，要进行闭环检测。这两种情况都涉及位置识别。基于图像的位置识别方法主要有 3 种：</p><ul class="lvl-0"><li class="lvl-2"><p>Image-to-image matching：将地图看成一系列图像组成的序列，用当前观测图像与地图中的每幅图像匹配</p></li><li class="lvl-2"><p>Image-to-map matching：将地图看成一系列地图点组成的点云，用当前观测图像与地图点云匹配</p></li><li class="lvl-2"><p>Map-to-map：用当前几帧构建出的局部小地图与全局大地图匹配</p></li></ul><p>Image-to-image matching 在大环境下尺度特性更好。为了提高匹配效率，通常用到词袋模型(Bag-of-Words, BoW)。</p><p>词袋模型的思想：以两篇文章的相似度为例，以两篇文章中存在的所有单词构成一个字典，统计字典中单词在文章中出现的次数，组成一个表征向量，对比两篇文章的表征向量就可以表示相似度。而在图像匹配问题中，把图像特征点看成单词。</p><h3 id="构建视觉单词的离线字典">构建视觉单词的离线字典</h3><p>在使用词袋模型时，需要先训练得到一个字典。ORB 特征描述子为一个 256 bit 的二进制向量。在一个庞大的图像数据集中进行离线训练，其实就是将数据集中提取出的所有 ORB 特征点放入向量空间，采用海明距离度量向量空间中的特征点之间的距离，然后对特征点进行聚类。为了提高搜索效率，对前面的聚类结果再次进行聚类，经过 d 次聚类后就得到了一个具有 d 层的 k 叉树，如下图所示。</p><img src="https://pic1.imgdb.cn/item/678cc69cd0e0a243d4f5a543.jpg" style="zoom:50%;" /><p>上面生成的树中一共包含 $k^d$ 个节点。如果不借助树结构，要查询某个特征点属于哪个单词，需要计算和全部的节点的海明距离；而借助树结构，只需要从根节点开始，计算和该层所有节点的海明距离，然后选择最小的节点往下一层继续，这样只需要 $k\times d$ 次计算，搜索效率大大提高。</p><p>在训练 k 叉树字典时，还要给每个单词赋予一个权重（IDF），单词在图像训练集中越常见，IDF 越低。</p><h3 id="构建图像序列的在线数据库">构建图像序列的在线数据库</h3><p>得到离线字典后，就可以查找字典来解决一些问题。如果将查字典的过程都记录成笔记，就可以利用笔记更快地解决问题。这个过程就是构建图像序列的在线数据库，包括图像表征向量、正向索引和反向索引。</p><p>图像表征向量，就是图像中特征点的统计直方图。在 k 叉树中找到特征点属于哪个单词的同时，还要记录下每个单词在图像中出现的频率（词频） $TF=\frac{n_i}{n}$。那么一张图像就可以用一个表征向量 $v$ 来表示，$v$ 的维度为字典单词总数，每个元素的取值为单词的权重，这里的权重通常为 TF-IDF，即 $weight_i=TF_i \times IDF_i$。由于一张图像中包含的单词很少，实际实现中 $v$ 以稀疏方式表示。</p><p>正向索引和反向索引其实就是两张映射表，正向索引是指图像到字典树中各个节点的映射关系，反向索引是指字典树中叶子节点到各个图像的映射关系，如下图所示。</p><p>在计算图像的表征向量时，图像中每个特征点都会从字典根节点往下一直搜索到叶子节点，每个特征点对应一条节点遍历路径，将图像中所有特征点遍历过的节点都记录下来，就得到了该图像的正向索引。为工作空间的每张图像构建正向索引，通过正向索引就很容易查询出图像中各个特征点的层次分布情况。</p><p>而将字典中每个单词从属的图像都记录下来，就得到了叶子节点的反向索引。通过反向索引可以很快地查询出包含该单词的图像。</p><img src="https://pic1.imgdb.cn/item/678ccaf6d0e0a243d4f5a5d3.jpg" alt="索引" style="zoom:50%;" /><h3 id="应用词袋模型">应用词袋模型</h3><p>词袋模型应用分为三个阶段：构建离线字典、构建在线数据集、应用。这里应用主要是加速帧间的特征匹配、重定位和闭环检测，过程如下图所示。</p><img src="https://pic1.imgdb.cn/item/678cce72d0e0a243d4f5a6e8.jpg" alt="应用词袋模型流程" style="zoom:50%;" /><p>计算两帧图像（A 和 B）之间的特征匹配，利用两个图像的正向索引信息来缩小匹配范围。如下图所示，假设字典层数为 4 ，分支数为 2。选取某个层（例如 2 层），然后将图像 A 和 B 中包含在同一节点内的特征点 ${f_i^A}$ 和 ${f_i^B}$ 进行匹配即可。正是由于包含在同一节点内的特征点具有较高相似性，这就大大缩小了匹配范围。考虑两种极端情况，如果选择字典树的顶层，由于顶层节点包含所有特征点，就属于暴力匹配的情况；如果选择最底层，由于底层节点包含特征点的范围太小，因此没有被划入同一节点内的真实匹配点对，导致无法匹配。一般选取中间层的节点来加速帧间匹配。</p><img src="https://pic1.imgdb.cn/item/678ccf75d0e0a243d4f5a718.jpg" style="zoom:67%;" /><p>而重定向和闭环检测，就是找出当前图像和以往图像序列中哪些图像很相似。在词袋模型帮助下，根据反向索引表，找到当前图像提取的单词在反向索引表中对应的所有图像，然后将当前图像和找到的这些图像对比即可，这就不需要逐一和以往所有图像进行对比。如下图所示。</p><img src="https://pic1.imgdb.cn/item/678cd448d0e0a243d4f5a792.jpg" style="zoom:67%;" /><h2 id="追踪线程">追踪线程</h2><p>追踪线程从相机获取输入图像，并输出每帧图像的相机位姿信息用于定位，同时从众多的输入图像中挑选一些有代表性的关键帧给接下来的局部建图线程，如下图所示。在单目情况下，追踪线程需要先完成地图初始化，在已有地图点云的基础上才能执行追踪任务，下面主要讨论在已有地图云点上的追踪过程。</p><img src="https://pic1.imgdb.cn/item/678cf311d0e0a243d4f5ac02.jpg" style="zoom:50%;" /><h3 id="特征提取">特征提取</h3><p>每个从相机输入到追踪线程的图像都要先提取 ORB 特征，步骤包括：构建图像金字塔、提取 FAST 角点、计算特征描述子等。这里有一个特殊的处理，为了让特征点在图像中分布尽量均匀，提取过程中加入了额外条件，将图像划分成网格，每个网格内必须要提取出一定数量的角点。</p><h3 id="初始位姿估计">初始位姿估计</h3><p>追踪的目的是为了实时确定相机在世界坐标系中的位姿，也就是定位。定位常常分为粗定位和精定位，粗定位可以快速获得一个不太精确的初始位姿估计，精定位在初始位姿估计的基础上通过复杂运算得到更精准的位姿估计。这里讨论的初始位姿估计就属于粗定位，而后面讨论的局部地图追踪可以理解为精定位。</p><p>这一阶段包括三种追踪方法：恒速模型追踪、用参考关键帧来追踪、重定位追踪。</p><p>如果上一帧输入图像 $F_{k-1}$ 被追踪成功，那么假设相机继续以 $F_{k-2}$ 到 $F_{k-1}$ 的速度从 $F_{k-1}$ 运动到 $F_{k}$ ，也就是可以预测从 $F_{k-1}$ 到 $F_{k}$ 的位姿转移量 $T$ ，接着讲图像 $F_{k-1}$ 中观测到的地图云点通过 $T $ 变换到 $F_k$ 坐标系，再利用地图云点投影到当前图像的关系，最小化重投影误差来求解 $T$ 的优化值，这就转到了 3D-2D 模型问题。这就是恒速模型追踪。</p><p>如果相机运动太快或者抖动，导致恒速模型追踪的计算结果 $T$ 失效，就要扩大追踪的搜索范围，即局部地图上的一系列关键帧。利用词袋模型，将当前帧图像与局部地图中的一些关键帧匹配，其中匹配度最高的作为参考关键帧。如果参考关键帧与当前关键帧匹配度较好（匹配点数不小于 15），就可以用 $T$ 将参考帧中观察到的地图云点变换到当前帧坐标系，然后最小化重投影误差来求 $T$ ，这就转到有 3D-2D 模型问题。这是用参考关键帧来追踪。</p><p>如果参考关键帧与当前帧的匹配并不好，或者求出的位姿观测不到足够的地图点云，那用参考关键帧来追踪也失败了。这是就要重定位了。利用词袋模型，在全局关键帧中找出匹配较好的帧用于 PnP 的 RANSAC 迭代，每轮迭代后都要判断在求出的当前帧位姿上是否能观测到足够多的额地图云点，如果可以，结束迭代并且重定位成功，如果迭代完全部关键帧后都不满足，则重定位失败，追踪线程处于彻底丢失状态，只能将整个 SLAM 系统重启。这就是重定位追踪。</p><blockquote><img src="https://pic1.imgdb.cn/item/678d2873d0e0a243d4f5b698.png" style="zoom:80%;" /><p>图片来自 <a href="https://blog.csdn.net/qq_41694024/article/details/128321440">ORB-SLAM2 — Tracking::Track 追踪线程解析</a></p></blockquote><h3 id="局部地图追踪">局部地图追踪</h3><p>在上面的初始位姿估计中，三种追踪方法本质上都是利用当前帧与追踪帧之间的共视地图云点求相机位姿，但两帧图像之间的共视点是很有限的。</p><p>局部地图追踪，就是在初始位姿估计完成的基础上，利用当前帧与局部地图上的多个关键帧建立共视关系，并通过所有这些共视地图点云与当前帧的投影关系，对位姿进行更精确的求解。</p><h3 id="新关键帧挑选">新关键帧挑选</h3><p>追踪线程最后一步就是新关键帧的挑选。目的是尽可能快速地从普通帧挑选出有代表性的帧，也就是该帧与上一个挑选帧有足够的时间间隔、帧中能观测到足够多地图云点等。</p><h2 id="局部建图线程">局部建图线程</h2><p>由于追踪线程挑选关键帧的速度较快，因此被挑选出来的新关键帧存放在缓冲区内。局部建图线程不断从缓冲区取出关键帧处理，更新当下的局部地图，并将每个处理过的当前关键帧输出给闭环检测线程。如下图所示。</p><img src="https://pic1.imgdb.cn/item/678d1a0fd0e0a243d4f5b460.jpg" style="zoom:80%;" /><p>局部建图线程主要包括：关键帧插入、近期地图点筛选、新地图云点重建、局部 BA优化和局部关键帧筛选。</p><h3 id="关键帧插入">关键帧插入</h3><p>每个从缓冲区中取出的关键帧，首先要在词袋模型中计算表征向量，也就是将该关键帧更新到词袋模型的在线数据库中。然后将地图中有共视关系但没有与该帧建立联系的云点建立关联，这些新建立关联的云点称为近期地图点。接着计算该关键帧与地图中已有关键帧的共视连接权重，其实就是新建连接边，以将关键帧插入到共视关系图中。最后就是将关键帧加入到地图结构中。</p><h3 id="近期地图点筛选">近期地图点筛选</h3><p>在关键帧插入的过程中，保留了一些近期地图点，必须将其中一些质量差的云点剔除（例如被同时观测的关键帧较少、上一个能观测到的关键帧太久远等），这是维护地图点鲁棒性的重要机制。</p><h3 id="新地图云点重建">新地图云点重建</h3><p>对于每个新插入的关键帧，借助共视关系图与邻近的关键帧进行匹配，将该新关键帧还未映射到地图云点的特征点进行三角化重建，生成新的地图云点。这些新的地图云点如果检验合格就加入到地图结构中，并保留为近期地图点。</p><h3 id="局部-BA-优化">局部 BA 优化</h3><p>等缓冲区的关键帧都被取出来并处理后，就可以将当前帧局部的几个关键帧以及地图云点放入局部 BA 中优化。这里把各个关键帧和地图云点看成节点，已知初始位姿；关键帧与关键帧之间的约束边由共视关系给出，关键帧与地图云点之间的约束由投影关系给出。</p><h3 id="局部关键帧筛选">局部关键帧筛选</h3><p>当局部 BA 优化完成后，对局部地图中关键帧筛选，将冗余的关键帧剔除，以保证地图关键帧的鲁棒性。</p><p>值得注意的是，上面五个步骤并不是简单的顺序执行。因为缓冲区中有多个关键帧处理，所以五个步骤实际上是以循环和条件判断混合的方式出现的。</p><h2 id="闭环线程">闭环线程</h2><p>在局部建图线程处理后的每个当前关键帧，都要送入闭环线程，一旦回环检测通过，就对全局地图进行回环修正，如下图所示。</p><img src="https://pic1.imgdb.cn/item/678d223dd0e0a243d4f5b593.jpg" style="zoom:80%;" /><h3 id="候选回环">候选回环</h3><p>利用词袋模型，将数据库中与当前关键帧相似度较高的帧选出来，这些帧就是候选回环帧。</p><h3 id="计算相似变换">计算相似变换</h3><p>计算当前关键帧与每个候选回环帧之间的变换关系。因为单目 SLAM 存在尺度漂移问题，所有变换除了旋转平移之外，还包含一个尺度因子。如果有足够多的数据能计算出相似变换，并且该变换能保证当前关键帧和候选回环帧之间有足够多的共视点，则接纳这个候选回环帧，回环检测成功。</p><h3 id="回环融合">回环融合</h3><p>当前关键帧和被接纳的候选回环帧之间的相似变换量描述了累积误差的大小，可以利用该变换量修正当前关键帧及其邻近关联帧的累积误差，并将那些因累差而不一致的地图点融合到一起。</p><h3 id="位姿图优化">位姿图优化</h3><p>虽然回环融合可以修正当前关键帧及其邻近关联帧的累积误差，但地图中那些和当前关键帧无共视关系的帧还没得到修正，因此需要用全局优化来修正。考虑到效率问题，这里全局优化只将全局地图上的关键帧位姿量当成优化变量，而地图点不是优化变量，这也称为位姿图优化。</p>]]></content>
      
      
      <categories>
          
          <category> SLAM 学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ORB-SLAM2 前置知识</title>
      <link href="/2024/12/09/ORB-SLAM2%20%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/"/>
      <url>/2024/12/09/ORB-SLAM2%20%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1>ORB-SLAM2 前置知识</h1><p>ORB-SLAM2 算法是视觉 SLAM 特征点法的典型代表。特征点法中除了最基本的特征提取和特征匹配外，还涉及相机在三维空间运动时位姿的表示，以及帧与帧之间配对特征点、环境地图点、相机位姿等共同形成的多视图几何关系。</p><h2 id="特征点法">特征点法</h2><h3 id="特征提取">特征提取</h3><p>在 SLAM 中，处于运动状态的相机拍摄出的图像旋转和尺度都很敏感，算法实时性要求很高，而 ORB 特征具有很好的旋转和尺度不变性，并且提取耗时很短，在 ORB-SLAM2 中使用的就是 ORB 特征。</p><p>如下图所示，在图像中提取到3个 ORB 特征点，每个特征点包含两个信息：像素坐标和描述子。描述子用来表示特征点的身份，ORB 特征的描述子由二进制序列构成，描述子主要为了方便后续特征匹配，如果两个特征点的描述子相似度很高，就可以认为这两个特征点是一对匹配点。</p><p><img src="https://pic1.imgdb.cn/item/677f9082d0e0a243d4f28afc.jpg" alt="特征提取"></p><h3 id="特征匹配">特征匹配</h3><p>特征匹配是解决特征点法 SLAM 中数据关联问题的关键，也就是找到那些在不同角度拍摄的图像中都出现的特征点。假设相机在两个视角拍摄到两幅图像，如下图。先从图像 A 中提取到 $A={P_A^1, P_A^2, P_A^3}$ 特征点，在从 B 提取到 $B={P_B^1, P_B^2, P_B^3, P_B^4}$ ，那匹配过程就是找出 $A,B$ 两个集合中各点的对应关系。</p><p><img src="https://pic1.imgdb.cn/item/677f9272d0e0a243d4f28e15.jpg" alt="特征匹配"></p><p>ORB 特征点的匹配度由两个特征点描述子的海明距离计算，海明距离越小匹配度越高。最简单的匹配方法就是暴力匹配，但特征点数量很大时工作效率低下。实际工程中，一般使用 K 最近邻匹配（KNN）、快速近似最近邻匹配（FLANN）等匹配算法。</p><p>需要注意的是，当环境场景为白墙、地面等重复单一场景时，极易出现误匹配。如果误匹配点过多，会使得后续位姿和地图点估计出错，严重时整个 SLAM 系统将会崩溃。</p><h3 id="模型构建">模型构建</h3><p>特征提取和特征匹配后，就可以构建相应模型用于相机位姿和地图点的求解。帧与帧之间配对特征点、环境地图点、相机位姿等都可以用多视图几何关系来建模，如下图。</p><img src="https://pic1.imgdb.cn/item/677f97b8d0e0a243d4f29634.jpg" alt="多视图几何" style="zoom:50%;" /><h2 id="三维空间运动">三维空间运动</h2><p>相机运动过程可以看成三维空间的刚体运动。相机位姿由 3 自由度旋转量和 3 自由度平移量共同表示。旋转量表示相机在空间中的朝向，具体表达方式包括欧拉角、旋转矩阵、四元数等；平移量表示相机在空间中的位置，即 x、y、z 坐标值。</p><h3 id="欧拉角">欧拉角</h3><p>用欧拉角描述旋转姿态的两种最常见形式：</p><ul class="lvl-0"><li class="lvl-2"><p>旋转角度为 $(\alpha,\beta,\gamma)$，旋转顺序为 $(z-y-x)$，旋转方式为内旋，也就是 yaw-pitch-roll 顺序。</p></li><li class="lvl-2"><p>旋转角度为 $(\alpha,\beta,\gamma)$，旋转顺序为 $(x-y-z)$，旋转方式为外旋，也就是 roll -pitch-yaw 顺序。</p></li></ul><p>欧拉角表示看起来直观，但存在万向锁死锁问题（Gimbal Lock）。例如 $(z-y-x)$ 旋转规则下，首先绕 $z_0$ 轴旋转 yaw 角度，再绕新的 $y_1$ 轴旋转 pitch 角度，如果 pitch 角度为 $+90^{\circ}$ 或 $-90^{\circ}$ ，那么新的 $x_2$ 轴将和 $z_0$ 轴重合，最后绕新的 $x_2$ 轴旋转 roll 角度，其实就是绕 $z_0$ 轴旋转。上面这种情况，具有 3 个自由度的欧拉角旋转过程就退化成 2 个自由度的旋转过程了，这种丢失自由度的情况就是欧拉角中所谓的奇异性。因此，欧拉角只适用绝对姿态的直观表示，不适用于需要相对姿态表示（比如姿态插值计算、姿态增量计算）。这就引出了旋转矩阵。</p><h3 id="旋转矩阵">旋转矩阵</h3><p>$z -y-x$ 内旋规则的欧拉角对应的旋转矩阵如式 $(1)$ 所示，$x-y-z$ 外旋规则的欧拉角对应的旋转矩阵如式 $(2)$ 所示。可以看出两种方式旋转得到的结果是等价的。</p><p><img src="https://pic1.imgdb.cn/item/677fbefdd0e0a243d4f2c9ad.png" alt="1"></p><p>用 9 个量的旋转矩阵表示三维空间的旋转虽然避免了奇异性，但具有很大冗余性。三维旋转式一个三维流形，用 4 个量表示就能避免奇异性，这就引出了四元数。</p><h3 id="四元数">四元数</h3><p>下面讨论的是 Hamilton 四元数，定义如式 $(3)$ 所示。<br>$$<br>\begin{align*}<br>\boldsymbol{q} &amp;= q_0+q_1\cdot i+q_2\cdot j+q_3\cdot k \<br>&amp;= [q_0,(q_1,q_2,q_3)]^T = [q_0,q_1,q_2,q_3]^T \tag{3}<br>\end{align*}<br>$$<br>其中，$i<sup>2=j</sup>2=k^2=-1,ij=k,ji=-k,jk=i,kj=-i,ki=j,ik=-j$ 。</p><p>模长为 1 的四元数都是单位四元数，实际应用上一般使用的四元数都是指单位四元数。利用式 $(4)$ 和 $(1)、(2)$ 可以得到对应的四元数。</p><p><img src="https://pic1.imgdb.cn/item/677fcd40d0e0a243d4f2cc6f.png" alt="2"></p><p>这样就可以得到欧拉角、旋转矩阵、四元数的相互转换方法。三者的比较可以参考下表。</p><p><img src="https://pic1.imgdb.cn/item/677fca9ad0e0a243d4f2cbd3.jpg" alt="欧拉角、旋转矩阵、四元数比较"></p><h3 id="转移矩阵">转移矩阵</h3><p>上面讨论了表示旋转的方法，再加上表示平移的方法，就能描述物体在三维空间的转移关系了。</p><p>假设有一个点 $P$，该点在相机坐标系 $o_{camera}$ 中的坐标为 $P_c=[x_c,y_c,z_c]^T$ ，现在让该点随相机坐标系一起进行旋转和平移运动，旋转矩阵用 $R$ 描述，平移用 $t=[t_x,t_y,t_z]^T$ 描述，那此时该点在世界坐标系 $o_{world}$ 中的坐标 $P_w=[x_w,y_w,z_w]^T$ 可表示为式 $(5)$ 。</p><p><img src="https://pic1.imgdb.cn/item/677fce3bd0e0a243d4f2ccad.png" alt="3"></p><p>可以设</p><p><img src="https://pic1.imgdb.cn/item/677fd140d0e0a243d4f2cd0e.png" alt="4"></p><p>那么式 $(5)$ 可以写成齐次坐标形式，如式 $(6)$ 所示，$T$ 也称为转移矩阵。利用式 $(6)$ ，已知点 $P$ 在两个不同坐标系下的坐标为 $P_c$ 和 $P_w$，则很容易求出两个坐标系间的转移关系 $T$。同理，知道转移矩阵也很容易实现两个不同坐标系下的坐标转换。</p><p><img src="https://pic1.imgdb.cn/item/677fd266d0e0a243d4f2cd4a.png" alt="5"></p><h3 id="李群、李代数">李群、李代数</h3><p>旋转矩阵内的各元素取值受到内在约束，即旋转矩阵为正交且旋转矩阵行列式为1。在采用优化方法进行 SLAM 位姿估计时，这种内在约束让优化求解变得很困难。因此这里引入李群、李代数概念，通过李群-李代数的转换可以去除这种内在约束，简化优化求解过程。李群李代数具体讨论可浏览此文章：<a href="https://hins-h.github.io/2025/12/10/%E6%9D%8E%E7%BE%A4%E3%80%81%E6%9D%8E%E4%BB%A3%E6%95%B0/">李群、李代数</a></p><h2 id="多视图几何">多视图几何</h2><p>有了用转移矩阵 $T$ 描述相机运动的知识，可以详细讨论多视图几何模型了。按照模型的已知条件不同，可以分为 2D-2D、3D-2D、3D-3D 三种情况。</p><h3 id="2D-2D-模型">2D-2D 模型</h3><p>如果不同视角拍摄到的两帧图像为已知量，就可以利用这两帧图像的匹配点对来求解地图点及相机位姿这些未知量。这个模型中，给定的已知条件是从一张 2D 图像到另一张 2D 图像的匹配信息，所以称为 2D-2D 模型。例如在单目 SLAM 初始化新地图点时就会用到这种模型。</p><p>如下图，假设环境中有一个点 $P$，相机在光心为 $O_1$ 和 $O_2$ 处观测点 $P$ 得到图像点 $p_1$ 和 $p_2$ ，相机从 $O_1$ 经旋转平移运动到 $O_2$，该运动过程可以用转移矩阵 $T$ 表示。</p><img src="https://pic1.imgdb.cn/item/6780e3c9d0e0a243d4f30988.jpg" style="zoom:33%;" /><p>这里假设相机使用无畸变内参模型。假设环境点 $P$ 在相机 $O_1$ 和 $O_2$ 坐标系下的坐标为 $P_{O_1}$ 和 $P_{O_2}$，对应像素点 $p_1、p_2$ 的坐标由式 $(7)、(8)$ 得到。式中 $z_1$ 和 $z_2$ 参数是像素点 $p_1、p_2$ 的深度，也叫尺度因子（无约束）。<br>$$<br>p_1=\frac{1}{z_1}K \cdot P_{O_1} \tag{7}<br>$$</p><p>$$<br>p_2=\frac{1}{z_2}K \cdot P_{O_2} \tag{8}<br>$$</p><p>而 $P_{O_1}$ 和 $P_{O_2}$ 很容易由转移关系进行转换，如式 $(9)$。<br>$$<br>P_{O_2} = R \cdot P_{O_1} + t \tag{9}<br>$$<br>联立式 $(7)\sim(9)$ ，推导过程如式 $(10)$ 所示。由于 $z_1$ 和 $z_2$ 是无约束的，推导过程中可以直接消掉。<br>$$<br>\begin{align*}<br>&amp; z_{2} \boldsymbol{K}^{-1} \boldsymbol{p}<em>{2} = \boldsymbol{R} \cdot (z</em>{1} \boldsymbol{K}^{-1} \boldsymbol{p}<em>{1}) + \boldsymbol{t}<br>\<br>&amp; \Updownarrow \text{左叉乘} \boldsymbol{t},\boldsymbol{t} \times \boldsymbol{t}=0<br>\<br>&amp; \boldsymbol{t} \times z</em>{2} \boldsymbol{K}^{-1} \boldsymbol{p}<em>{2} = \boldsymbol{t} \times \boldsymbol{R} \cdot (z</em>{1} \boldsymbol{K}^{-1} \boldsymbol{p}<em>{1})<br>\<br>&amp; \Updownarrow \text{左乘} (\boldsymbol{K}^{-1} \boldsymbol{p}</em>{2})^T,  (\boldsymbol{K}^{-1} \boldsymbol{p}<em>{2})^T \cdot (\boldsymbol{t} \times z</em>{2} \boldsymbol{K}^{-1} \boldsymbol{p}<em>{2}) = 0 \tag{10}<br>\<br>&amp; 0 = z</em>{1} (\boldsymbol{K}^{-1} \boldsymbol{p}<em>{2})^T \boldsymbol{t} \times \boldsymbol{R} \boldsymbol{K}^{-1} \boldsymbol{p}</em>{1}<br>\<br>&amp; = \boldsymbol{p}<em>{2}^T \boldsymbol{K}^{-T} \underbrace{\boldsymbol{t}^{\wedge} \boldsymbol{R}}</em>{\boldsymbol{E}} \boldsymbol{K}^{-1} \boldsymbol{p}<em>{1}<br>\<br>&amp; = \boldsymbol{p}</em>{2}^T  \underbrace{\boldsymbol{K}^{-T}\boldsymbol{E} \boldsymbol{K}^{-1}}<em>{\boldsymbol{F}} \boldsymbol{p}</em>{1}<br>\<br>&amp; = \boldsymbol{p}<em>{2}^T\boldsymbol{F} \boldsymbol{p}</em>{1}<br>\end{align*}<br>$$</p><p>（1）本质矩阵 $\boldsymbol{E}$ 和基础矩阵 $\boldsymbol{F}$</p><p>上面情况的对极几何关系可以用公式 $0= \boldsymbol{p}<em>{2}^T \boldsymbol{K}^{-T}\boldsymbol{E} \boldsymbol{K}^{-1} \boldsymbol{p}</em>{1} = \boldsymbol{p}<em>{2}^T\boldsymbol{F} \boldsymbol{p}</em>{1}$ 描述，这个公式也叫对极约束。式中定义本质矩阵 $\boldsymbol{E}=\boldsymbol{t}^{\wedge} \boldsymbol{R}$ ，基础矩阵 $\boldsymbol{F}=\boldsymbol{K}^{-T}\boldsymbol{E} \boldsymbol{K}^{-1}$ 。由于本质矩阵和基础矩阵只相差相机内参，所以两者在研究中其实是等价的，实际应用中通常使用更简洁的本质矩阵。</p><p>也就是图像中每个匹配点对都可以代入对极约束公式中构建出一个方程，如果有多对匹配点，就可以得到一个方程组，通过解方程组就可以求出本质矩阵。有研究表明，只需要 8 对匹配点就可以很好地解出本质矩阵（8 点法）。求出本质矩阵后，通过奇异值分解（SVD）方法，容易解算出相机位姿运动的 $\boldsymbol{R}$ 和 $\boldsymbol{t}$ 。整个过程如下图所示。</p><p><img src="https://pic1.imgdb.cn/item/6780e3c9d0e0a243d4f30987.jpg" alt="相机位姿运动解算"></p><p>（2）单应矩阵 $\boldsymbol{H}$</p><p>当被观测的环境点都在同一个平面上，那么相应图像中的匹配点对就满足单应关系。这其实就是对极约束的一种特殊情况。单应关系由 $\boldsymbol{p}_2=\boldsymbol{H} \cdot \boldsymbol{p}_1$ 描述，$\boldsymbol{H}$ 就是单应矩阵。解算过程与本质矩阵一样。</p><p>（3）三角化重建地图点</p><p>所谓三角化，就是观测点 $P$ 和两个相机位置 $O_1、O_2$ 构成的三角形，在已知边 $O_1O_2$ 、底角 $\angle PO_1O_2$、$\angle PO_2O_1$ 时，利用三角形关系就可以求解出环境点 $P$ 的深度。联立式 $(7)\sim(9)$ 并做适当推导，就得到了关于点 $P$ 的深度 $z_1$ 的方程，推导过程如式 $(11)$ 所示。<br>$$<br>\begin{align*}<br>&amp; z_{2} \boldsymbol{K}^{-1} \boldsymbol{p}<em>{2} = \boldsymbol{R} \cdot (z</em>{1} \boldsymbol{K}^{-1} \boldsymbol{p}<em>{1}) + \boldsymbol{t}<br>\<br>&amp; \Updownarrow \text{左叉乘} (\boldsymbol{K}^{-1} \boldsymbol{p}</em>{2}),(\boldsymbol{K}^{-1} \boldsymbol{p}<em>{2}) \times (\boldsymbol{K}^{-1} \boldsymbol{p}</em>{2})=0 \tag{11}<br>\<br>&amp; 0 = z_{1} (\boldsymbol{K}^{-1} \boldsymbol{p}<em>{2}) \times \boldsymbol{R} \cdot (\boldsymbol{K}^{-1} \boldsymbol{p}</em>{1}) + (\boldsymbol{K}^{-1} \boldsymbol{p}<em>{2}) \times t<br>\<br>&amp; 0 = z</em>{1} (\boldsymbol{K}^{-1} \boldsymbol{p}<em>{2})^{\wedge} \boldsymbol{R} (\boldsymbol{K}^{-1} \boldsymbol{p}</em>{1}) + (\boldsymbol{K}^{-1} \boldsymbol{p}<em>{2})^{\wedge} t<br>\end{align*}<br>$$<br>将 $p_1、p_2$ 和 $(R,t) $ 代入就可以求出 $z_1$ 了，这样就完成了对地图点 $P$ 的三角化重建了。理想情况下直接求解就可以得出 $z_1$ 了，但实际情况中 $p_1、p_2$ 的像素坐标携带测量噪声，解算出的 $(R,t) $ 也不一定完全准确，这就导致了 $0 \neq z</em>{1} (\boldsymbol{K}^{-1} \boldsymbol{p}<em>{2})^{\wedge} \boldsymbol{R} (\boldsymbol{K}^{-1} \boldsymbol{p}</em>{1}) + (\boldsymbol{K}^{-1} \boldsymbol{p}<em>{2})^{\wedge} t$，而是约等于0。那么构建最小二乘问题 $\text{arg } \underset{z_1}{\text{min}} || z</em>{1} (\boldsymbol{K}^{-1} \boldsymbol{p}<em>{2})^{\wedge} \boldsymbol{R} (\boldsymbol{K}^{-1} \boldsymbol{p}</em>{1}) + (\boldsymbol{K}^{-1} \boldsymbol{p}_{2})^{\wedge} t ||^2$，很容易求出 $z_1$。</p><p>（4）对地图点和相机位姿做 BA 优化</p><p>理论上，通过本质矩阵和单应矩阵解出 $(R,t) $ ，再进行三角化重建地图点 $P$，模型解析就完成了。但实际情况是求解出的 $(R,t) $ 和地图点 $P$ 都存在误差，误差有测量噪声、计算误差、匹配误差等因素引入。</p><p>那么，可以将解算出的地图点和相机位姿放入 BA 做优化，通过优化尽量减少误差。这里需要用到重投影误差 $e_i$，定义如式 $(12)$ 所示考虑所有地图点，通过最小化重投影误差的方式构建目标方式，描述如式 $(13)$ 所示。<br>$$<br>\boldsymbol{e}_i=\boldsymbol{p}<em>2^i-\frac{1}{z_2} \boldsymbol{K} \cdot \boldsymbol{T} \cdot \boldsymbol{P}</em>{O_1}^i \tag{12}<br>$$</p><p>$$<br>\boldsymbol{T},\boldsymbol{P}<em>{O_1} = \text{arg } \underset{T,P</em>{O_1}}{min} \sum_i||e_i||^2 \tag{13}<br>$$</p><h3 id="3D-2D-模型">3D-2D 模型</h3><p>如果已经得到一些地图点，并且当前帧图像中的特征点通过某种途径可以与地图中的已知点建立关联，根据这个模型可以求出相机位姿。这个模型中，给定的已知条件是从 3D 地图点到 2D 图像特征点的关联信息，所以称为 3D-2D 模型。比如，单目 SLAM 初始化完成后就可以得到一些已知地图点，或者双目/RGB-D 能直接给出 3D 环境观测点。这些情况下，当前帧图像对应的相机位姿解算就可以使用这个模型。</p><p>如下图，现在假设已知构建出很多地图点，此时相机从 $O_{k-1}$ 运动到 $O_K$，相机当前帧提取出很多特征点，其中 $p_j、p_{j+1}$ 特征点与上一帧图像中的特征点能匹配上，而上一帧图像的特征点已经知道和哪些地图点对应，也就是说当前帧图像 2D 特征点与 3D 地图点相关联。进一步根据这些信息可以求出相机运动 $(R,t)$ 。</p><img src="https://pic1.imgdb.cn/item/67811b60d0e0a243d4f31c36.jpg" alt="3D-2D模型" style="zoom:50%;" /><p>可以发现，上图中最典型的关系就是多组一一对应的 3D 地图点和 2D 特征点。为了讨论方便，将每对点记为 ${P_i,p_i}$ ，因此这个问题也被称为 PnP（Perspective-n-Point，n点透视）问题。求解 PnP 问题的方法有很多，比如 DLT、P3P、EPnP、BA优化等。</p><h4 id="DLT">DLT</h4><p>DLT（Direct Linear Transform）顾名思义就是直接解线性方程的方法来求解 PnP 问题。</p><p>现在假设 $O_{k-1}$ 坐标系下地图坐标点 $P_i=[x_i,y_i,z_i,1]^T$，$O_k$ 中的像素点 $p_i=[u_i,v_i,1]^T$ 与 $P_i$ 对应，那两者的投影关系如式 $(14)$ 所示。<br>$$<br>z_ip_i=K[R|t]P_i \tag{14}<br>$$<br>可以分情况来求解上面式子，一种情况是在相机内参 $K$ 未知时，DLT算法可以同时将相机内参 $K$ 和外参 $[R|t]$ 都求出来，也就是这个算法实现了相机内参自标定过程；另一种情况是 $K$ 已知，只求 $[R|t]$ ，下面讨论算法具体步骤。先将式 $(14)$ 展开成方程组，如式 $(15)$ 所示。</p><p><img src="https://pic1.imgdb.cn/item/67812797d0e0a243d4f31fbc.png" alt="1"></p><p>也就是说，一对投影点可以构造出一个线性方程，那么 n 对就可以构造出 $ \boldsymbol{A}<em>{2n\times 12}\cdot \boldsymbol{m}</em>{12\times 1}=\boldsymbol{0} $ ，方程中的向量 $\boldsymbol{m}<em>{12\times 1}$ 是由投影矩阵 $Pr=K[R|t]$ 中的元素顺序排列构造，系数矩阵 $\boldsymbol{A}</em>{2n\times 12}$ 由 n 对投影点构造。理想情况下，只需求解线性方程得出 $\boldsymbol{m}$ ，然后用 $\boldsymbol{m}$ 构造出投影矩阵 $Pr$ ，分解投影矩阵就能得到内参和外参。实际情况中国，噪声和误差等因素会导致线性方程不严格等于0，那么可以构建最小二乘问题来解方程，如式 $(16) $ 所示。<br>$$<br>\begin{align*}<br>\boldsymbol{m} &amp;=\text{arg } \underset{\boldsymbol{m}}{min}||\boldsymbol{A}\cdot \boldsymbol{m}||^2<br>\<br>&amp;=\text{arg } \underset{\boldsymbol{m}}{min}(\boldsymbol{m}^T\cdot \boldsymbol{A}^T\cdot \boldsymbol{A} \cdot \boldsymbol{m})<br>\<br>&amp; \text{令}|\boldsymbol{m}|=1,SVD(A)=\boldsymbol{U}\boldsymbol{S}\boldsymbol{V}<sup>T=\sum_{i=1}</sup>{12}s_iu_iv_i^T<br>\<br>&amp;=\text{arg } \underset{\boldsymbol{m}}{min}(\boldsymbol{m}^T\cdot \boldsymbol{V}\boldsymbol{S}\boldsymbol{U}^T\cdot \boldsymbol{U}\boldsymbol{S}\boldsymbol{V}^T \cdot \boldsymbol{m}) \tag{16}<br>\<br>&amp;=\text{arg } \underset{\boldsymbol{m}}{min}(\boldsymbol{m}^T\cdot \boldsymbol{V}\boldsymbol{S}<sup>2\boldsymbol{V}</sup>T \cdot \boldsymbol{m})<br>\<br>&amp;=\text{arg } \underset{\boldsymbol{m}}{min}(\boldsymbol{m}^T\cdot \sum_{i=1}<sup>{12}s_i</sup>2v_iv_i^T \cdot \boldsymbol{m})<br>\end{align*}<br>$$<br>系数矩阵 $A$ 通过 SVD 分解，如果取待求向量 $m$ 为正交矩阵 $V$ 的某个列向量，那么选择最小奇异值 $s_{12}$ 对应的特征向量 $v_{12}$ 为待求向量 $m$ 的取值，就可以使上式取最小值。这样 $m$ 能求出来，投影矩阵也就求出来了。那么分解投影矩阵为  $[B,b]$，并根据 $Pr$ 内部结构很容易求出内参和外参，如果内参已知，求外参就更容易了，如式 $(17)$ 所示。<br>$$<br>Pr=K[R|t]=KR[I|-t]=[KR|-KRt]=[B,b] \tag{17}<br>$$</p><h4 id="P3P">P3P</h4><p>另一种求解 PnP 问题的方法是 P3P 算法。P3P 算法的思路是通过不共线的 3 个 3D 地图点 $P_1、P_2、P_3$ 和 3 个 2D 像素点 $p_1、p_2、p_3$ 以及相机光心 $O$ 构成的三角形关系，求解 $(R,t)$ 。如下图，给定的地图点  $P_1、P_2、P_3$ 是前一帧相机坐标系下的坐标值，所给定的像素点 $p_1、p_2、p_3$，是当前帧相机坐标系下的坐标值。虽然 $P_1、P_2、P_3$ 坐标值不能直接在当前帧相机坐标系下使用，但从中可以得到三角形的边长 $P_1P_2、P_1P_3、P_2P_3$ 。而同样可以确定三角形 $p_1p_2p_3$  的边长 $p_1p_2、p_1p_3、p_2p_3$ 以及对应的三个夹角。基于上面数据可以求出 $OP_1、OP_2、OP_3$ 的长度，再结合夹角就可以求出 $P_1、P_2、P_3$ 在当前帧相机坐标系下的坐标值。利用 $P_1、P_2、P_3$ 在当前帧和上一帧的坐标值，通过 ICP 算法（后面 3D-3D 模型中会介绍）很容易求出 $(R,t)$ 。</p><img src="https://pic1.imgdb.cn/item/67826953d0e0a243d4f36cd2.jpg" style="zoom: 33%;" /><h4 id="EPnP">EPnP</h4><p>相对于 DLT 和 P3P，EPnP 算法在求解 PnP 问题上表现更稳定、高效。EPnP 算法的关键在于从地图点钟选出的四个控制点 $c_1、c_2、c_3、c_4$ 以及一个对应的参考点 $p_i$，四个控制点和一个参考点通过加权和的方式关联，如下图。</p><img src="https://pic1.imgdb.cn/item/67826953d0e0a243d4f36cd3.jpg" style="zoom: 33%;" /><p>可以从世界坐标系中选取 n 个已知地图点 $p_i$ 为参考点，而从世界坐标系中选取 4 个已知地图点 $c_j$ 为控制点。控制点只有 4 个，是选好就固定的，而参考点可以有很多个。每个参考点都通过加权参数与 4 个固定控制点基于加权和方式联系，如式 $(18)$。对于相机坐标系下 $p_i^c$ 和 $c_j^c$ 的关系，由于只是坐标系取值不同，各点之间的空间相对位置不变，所以加权和关系一样成立，如式 $(19)$。<br>$$<br>p_i<sup>w=\sum_{j=1}</sup>4 \alpha_{ij}c_j<sup>w，其中\sum_{j=1}</sup>4 \alpha_{ij}=1 \tag{18}<br>$$</p><p>$$<br>p_i<sup>c=\sum_{j=1}</sup>4 \alpha_{ij}c_j<sup>c，其中\sum_{j=1}</sup>4 \alpha_{ij}=1 \tag{19}<br>$$</p><p>那么在相机坐标系下，参考点 $p_i^c$ 与对应的像素点 $u_i$ 可以用投影方程描述，如式 $(20)$。式子化简过程与 DLT 类似，系数矩阵 $A_{2\times 12}$ 由参考点的加权系数、像素坐标和相机内参来构造，$h_{12\times 1}$ 由 4 个控制点在相机坐标系的 12 个坐标值构造。</p><p><img src="https://pic1.imgdb.cn/item/6782b10ad0e0a243d4f37d2b.png" alt="6"></p><p>对于上面的方程，和 DLT 算法的解法一样采用最小二乘和 SVD 等方法求解。解出上面方程，实际上是求出来 4 个控制点在相机坐标系的坐标值，结合 4 个点在世界坐标系下的坐标值，用 ICP 算法就可以找到控制点在两个坐标系间的变换关系，即 $(R,t)$。</p><p>总结一下，EPnP 算法实际是利用了控制点与参考点的加权关系在世界坐标系和相机坐标系中不变的性质，通过构造参考点的投影方程，但方程又不直接求参考点的坐标，而是巧妙运用参考点与控制点的加权和关系间接求出来控制点的坐标。EPnP 算法也是结合了 DLT 和 P3P 中的很多思想。</p><h3 id="3D-3D-模型">3D-3D 模型</h3><p>如果前后两帧图像中都能获得地图点信息，直接根据这个模型就可以求出相机位姿。该模型中，给定已知条件是从 3D 地图点到 3D 地图点的关联信息。</p><p>现在假设相机在 $O_{k-1}$ 处得到地图点 $P_1<sup>{k-1}、P_2</sup>{k-1}、P_3^{k-1}$，在 $O_{k}$ 处得到地图点 $P_1<sup>{k}、P_2</sup>{k}、P_3^{k}$ 。通过图像特征匹配等数据关联方式，已经知道对应的地图点。只要找出对应 3D 点的变换关系，就可以求出相机位姿。下面讨论 ICP 和 BA 优化。</p><h4 id="ICP">ICP</h4><p>ICP 算法用于求解两组点云之间的位姿变换，具体分为点云数据关联已知的解法和点云数据关联为止的解法。3D-3D 模型中的 ICP 属于点云数据关联已知的情况。</p><p>假设给定了两组点云 $p={p_1,\dots,p_n}$ 和 $p<sup>{\prime}={p_1</sup>{\prime},\dots,p_n^{\prime}}$ ，并且点云中的每个点通过下标一一匹配。在考虑噪声的情况下，构建最小二乘问题，求解出 $(R,t)$，如式 $(21)$ 所示。<br>$$<br>\text{arg }\underset{R,t}{min}\sum_{i=1}^n ||p_i^{\prime}-(R\cdot p_i+t)||^2 \tag{21}<br>$$<br>可以将两个点云去质心后再构建最小二乘问题，如式 $(22)$ 所示。<br>$$<br>q_i=p_i-\bar{p}, \bar{p}=\frac{1}{n}\sum_{i=1}^np_i<br>\<br>q_i<sup>{\prime}=p_i</sup>{\prime}-\bar{p^{\prime}}, \bar{p<sup>{\prime}}=\frac{1}{n}\sum_{i=1}</sup>np_i^{\prime}<br>\<br>\text{arg }\underset{R,t}{min}\sum_{i=1}^n ||p_i^{\prime}-(R\cdot p_i+t)||^2=\text{arg }\underset{R,t}{min}\sum_{i=1}^n \bigg{\big|\big|q_i^{\prime}-R\cdot q_i\big|\big|<sup>2+\big|\big|\bar{p</sup>{\prime}}-R\cdot \bar{p}-t\big|\big|^2\bigg} \tag{22}<br>$$<br>首先将第一个加法项展开化简，然后利用 SVD 就能求出 $R$ ，如式 $(23)$ 所示。<br>$$<br>\text{arg }\underset{R,t}{min}\sum_{i=1}^n \big|\big|q_i^{\prime}-R\cdot q_i\big|\big|^2=<br>\text{arg }\underset{R,t}{min}\sum_{i=1}^n \big( q_i^{\prime T} q_i<sup>{\prime}-2q_i</sup>{\prime T}Rq_i+q_i<sup>TR</sup>TRq_i\big)<br>\<br>\Leftrightarrow<br>\text{arg }\underset{R,t}{min}\sum_{i=1}<sup>n-q_i</sup>{\prime}Rq_i=\text{arg }\underset{R,t}{min}\bigg( -tr(R\sum_{i=1}<sup>nq_i</sup>{\prime T}q_i) \bigg) \tag{23}<br>$$<br>令 $M=\sum\limits_{i=1}<sup>nq_i</sup>{\prime T}q_i$ ，利用 SVD 进行分解得到 $SVD(M)=USV^T$，从而求得 $R=UV^T$。然后将求出的 $R$ 代入第二个加法项，很容易得到 $t=p^{\prime T}-R\cdot p^{\prime}$。</p><h4 id="BA-优化">BA 优化</h4><p>另一种求解方法就是对式 $(21)$ 问题直接进行 BA 优化求解。BA 优化中，优化变量一般写成变换矩阵 $T$ 的形式，优化过程既可以对位姿 $T$ 进行优化，也可以同时对点云 $P$ 进行优化，如式 $(24)、(25)$  所示。<br>$$<br>T=\text{arg }\underset{T}{min}\sum_{i=1}^n \big|\big|p_i^{\prime}-T\cdot p_i\big|\big|^2 \tag{24}<br>$$</p><p>$$<br>T,p=\text{arg }\underset{T,p}{min}\sum_{i=1}^n \big|\big|p_i^{\prime}-T\cdot p_i\big|\big|^2 \tag{25}<br>$$</p><p>在 3D-3D 模型中，BA 优化过程对位姿 $T$ 的初值不敏感，鲁棒性较强。但由于其强依赖于点云 3D 坐标，因此计算出来的位姿精度会比 3D-2D 模型中的低。</p>]]></content>
      
      
      <categories>
          
          <category> SLAM 学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LOAM</title>
      <link href="/2024/11/27/LOAM%20%E7%AE%97%E6%B3%95/"/>
      <url>/2024/11/27/LOAM%20%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1>激光SLAM LOAM</h1><p>  不管是 Gmapping 还是 Cartographer，通常都是采用单线激光雷达作为输入，并且只能在室内环境运行。而 LOAM 算法利用多线激光雷达，能构建出 3D 点云地图，可以用于室外环境。</p><h2 id="核心思想">核心思想</h2><p>  LOAM 的核心思想是将 SLAM 问题拆分为独立的定位和建图分别来进行处理，过程如下图所示。</p><p><img src="https://pic.imgdb.cn/item/6765613dd0e0a243d4e74025.jpg" alt="LOAM算法框架"></p><p>  首先，特征提取模块（point cloud registration）从雷达点云中提取特征点（corner、surface）。然后，定位模块（lidar odometry）利用 Scan-to-scan 方法对相邻两帧雷达点云中的特征点进行匹配，这种帧间匹配能得到较低精度的里程计，用该里程计来校正雷达特征点云的运动畸变。接着，建图模块（lidar mapping）利用 Scan-to-map 方法进行高精度定位，该方法以前面低精度的里程计作为位姿初始值，将校正后的雷达特征点云与地图进行匹配，这种扫描帧到地图的匹配能得到较高进度的里程计（1 Hz 里程计），基于该高精度的里程计所提供的位姿将校正后的雷达特征点云加入已有地图。最后将低精度里程计和高精度里程计融合，输出更新速度和精度都较高的里程计（ 10Hz 里程计输出）。</p><p>  LOAM 算法的价值主要体现在两个方面：一方面是 LOAM 解决了雷达运动畸变问题，另一方面解决了建图效率问题。雷达运动畸变是一个很普遍的问题，LOAM 利用帧间特征匹配得到的里程计来校正雷达运动畸变，使得低成本的雷达的应用成为可能。而 SLAM 问题本来计算量就很大，处理 3D 点云数据时会更大，LOAM 利用低精度里程计和高精度里程计将 SLAM 问题巧妙地拆解成独立的定位和建图来进行处理，大大降低了计算量。</p><h2 id="主要模块">主要模块</h2><p>  特征提取模块从雷达点云中提取特征点。特征提取过程其实很简单，即对当前点云中的每个点计算平滑度，将平滑度小于某阀值（min）的点判断为 cormer 特征点，而平滑度大于某阈值（max）的点判断为 surface  特征点。所有的 corner 特征点被存放在 corner 点云中发布，所有的 surface 特征点被存放在 surface 点云中发布，也就是说特征提取结果将发布到两个点云中。</p><p>  定位模块利用 Scan-to-scan 方法对相邻两帧雷达点云中的特征点进行匹配。这里的匹配属于帧间匹配，利用前后两帧配对的特征点，很容易计算其位姿转移关系。在低速运动场景，直接利用帧间特征匹配就能得到低精度的里程（10Hz里程计），可利用该里程计在匀速模型假设下对雷达运动畸变做校正。在高速运动场景，就需要借助IMU、VO、轮式里程计等提供的外部定位信息来加快帧间特征匹配速度，以响应高速运动场景下位姿的变化，同时这些外部定位信息可以用于雷达运动畸变校正。</p><p>  建图模块利用 Scan-to-map 方法进行高精度定位，该方法以前面低精度的里程计作为位姿初始值，将校正后的雷达特征点云与地图进行匹配，这种扫描到地图的匹配能得到较高精度的里程计（1Hz里程计），基于该高精度的里程计所提供的位姿可将校正后的雷达特征点云加入已有地图。</p><p>  定位模块输出的里程计虽然精度较低，但是更新速度高。而建图块输出的里程计虽然精度较高，但是更新速度低。将二者融合可以得到更新速度和精度都较高的里程计，合通过插值过程实现。以1Hz的高精度里程计为基准，利用10Hz的低精度里程计对其进行插值，那么1Hz的高精度里程计就能以10Hz速度输出了。</p><p>  如果激光雷达本身帧率很高或者有IMU、VO、轮式里程计等外部定位辅助，且建图模块输出的里程计更新速度很高，那么里程计融合模块中的插值过程也就没有必要了。</p>]]></content>
      
      
      <categories>
          
          <category> SLAM 学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Cartographer</title>
      <link href="/2024/11/25/Cartographer/"/>
      <url>/2024/11/25/Cartographer/</url>
      
        <content type="html"><![CDATA[<h1>激光SLAM Cartographer</h1><p>Gmapping 属于基于滤波方法的 SLAM 系统，无法构建大规模的地图，而基于优化的方法可以，cartographer 就是基于优化方法的 SLAM 系统。</p><p>基于优化方法的激光 SLAM 已经不是一个新的研究领域了，Cartographer 算法主要是在提高建图精度和提高后端优化效率方面做了创新，而且 Cartographer 算法是一个多传感器融合建图算法。</p><p>基于优化方法的 SLAM 系统通常采用前端局部建图、闭环检测、后端全局优化这种经典框架，如下图所示。</p><p><img src="https://pic.imgdb.cn/item/67613e45d0e0a243d4e53da3.jpg" alt="基于优化的SLAM经典框架"></p><h2 id="局部建图">局部建图</h2><p>局部建图就是利用传感器扫描数据构建局部地图的过程，机器人位姿点、观测数据和地图之间通过约束量构建联系。如果机器人位姿准确的情况下，可以把观测到的路标直接添加进地图，但由于从机器人运动观测模型得到的机器人位姿存在误差，所以需要先用观测数据对这个预测位姿进行进一步更新，以更新后的机器人位姿为基准来将对应的观测加入地图。</p><h3 id="观测更新方法">观测更新方法</h3><p>用观测数据对这个预测位姿进行进一步更新，主要有下面几种方法：Scan-to-scan matching、Scan-to-map matching、Pixel-accurate scan matching。</p><p>最简单的更新方法就是 Scan-to-scan matching 方法。由于机器人相邻两个位姿对应的雷达扫描轮廓存在较大的关联性，在预测位姿附近范围内将当前帧雷达数据与前一帧雷达数据进行匹配，以匹配位姿为机器人位姿的更新量。但单帧雷达数据包含的信息太少，直接用相邻两帧雷达数据进行匹配更新会引入较大误差，并且雷达数据更新很快，这将导致机器人位姿的误差快速累积。</p><p>而 Scan-to-map matching 方法则不同，采用当前帧雷达数据与已构建出的地图进行匹配。已构建出的地图信息相对丰富稳定，因此不会导致机器人位姿的误差快速累积的问题，Cartographer 的局部建图就是采用这种方法。</p><p>Pixel-accurate scan matching 方法匹配窗口内的探索粒度更精细，能得到精度更高的位姿，缺点是计算代价太大，而 Cartographer 闭环检测用的就是这种方法。</p><img src="https://pic.imgdb.cn/item/67614a9ad0e0a243d4e56590.jpg" alt="Scan-to-scan与Scan-to-map对比" style="zoom:50%;" /><h3 id="Cartographer-地图结构">Cartographer 地图结构</h3><p>了解局部建图具体过程之前，先了解一下地图的结构。Cartographer 采用局部子图（submap）来组织整个地图，submap 则由若干扫描帧（scan）构成，所有 submap 构成全局地图（submaps）。如下图所示。</p><img src="https://pic.imgdb.cn/item/67614d72d0e0a243d4e56cdd.jpg" alt="地图结构" style="zoom: 33%;" /><p>无论是雷达扫描帧、局部子图还是全局地图，它们之间都是通过位姿关系进行关联的。这里只考虑 2D SLAM 建图，位姿表示为 $\xi=(\xi_x,\xi_y,\xi_{\theta})$ 。</p><p>假设机器人初始位姿为 $\xi_1=(0,0,0)$，该位姿处雷达扫描帧为 $scan(1)$，并利用 $scan(1)$ 来初始化第一个局部子图 $submap(1)$ 。利用 Scan-to-map matching 方法计算 $scan(2)$ 相应的位姿 $\xi_2$ ，并基于 $\xi_2$ 将 $scan(2)$ 加入 $submap(1)$ 中。不断执行 Scan-to-map matching 方法添加新得到的雷达帧，直到新雷达帧观测不到 $submap(1)$ 之外的新信息，就完成了 $submap(1)$ 的创建。然后重复上面步骤构建新的局部子图 $submap(2)$ ，而所有局部子图就构成最终的全局地图 $submaps$ 。</p><p>可以发现，每个雷达扫描帧都对应着一个全局地图坐标系下的全局坐标，同时在对应的局部子图坐标系下也有一个局部坐标。而每个局部子图以第一个插入的雷达扫描帧为起始，该起始雷达扫描帧的全局坐标也就是该局部子图的全局坐标。这样的话，所有雷达扫描帧对应的全局位姿 $\Xi<sup>s={\xi_j</sup>s}(j=1,2,\cdots,n)$ ，以及所有局部子图对应的全局位姿 $\Xi<sup>m={\xi_i</sup>m}(i=1,2,\cdots,m)$ 通过 Scan-to-map matching 产生的局部位姿 $\xi_{ij}$ 进行关联，这些约束实际上就构成了位姿图。当检测到闭环时，对整个位姿图中所有的位姿量进行全局优化，那么 $\Xi<sup>s\text{和}\Xi</sup>m$ 中的所有位姿都会得到修正，每个位姿上对应的地图点也得到修正，这就是全局建图。</p><h3 id="利用-Scan-to-map-matching-方法构建局部子图过程">利用 Scan-to-map matching 方法构建局部子图过程</h3><p>局部子图构建过程涉及很多坐标系变换的内容。首先雷达扫描一周得到的距离点 ${h_k},k=1,2,\cdots,K$ 是以雷达旋转中心为坐标系进行取值，那么在一个局部子图中，以第一帧雷达位姿为参考，后加入的雷达帧位姿用相对转移矩阵 $T_{\xi} = (R_{\xi},t_{\xi})$ 表示。这样的话，雷达帧中的数据点 $h_k$ 就可以用式 $(1)$ 所示的公式转换成局部子图坐标系来表示。</p><p><img src="https://pic.imgdb.cn/item/67616150d0e0a243d4e57dc6.png" alt="1"></p><p>与 Gmapping 类似，Cartographer 中的子图也采用概率栅格地图。概率栅格地图就是连续 2D 空间被分成一个个离散的栅格，栅格的边长为分辨率，通常为 $5cm$ 。那么扫到的障碍点就替换成用该障碍点所占据的栅格来表示，用概率来描述栅格中是否有障碍物，概率越大就说明存在障碍物可能性越高。</p><p>接下来考虑新雷达数据加入子图，先按式 $(1)$ 将雷达数据转换到子图坐标系，这时雷达数据点会覆盖子图的一些栅格 ${M_{old}}$ ，每个栅格存在3种状态：未知、非占据（miss）、占据（hit）。如下图所示，雷达扫描点所覆盖的栅格就应为占据状态（hit）；而雷达扫描光束起点和终点之间肯定就没有障碍物，该区域的栅格应为非占据状态（miss）；而未被雷达扫到的点的栅格就应该为未知状态。</p><img src="https://pic.imgdb.cn/item/67615b44d0e0a243d4e57cb6.jpg" alt="雷达数据点栅格化" style="zoom: 33%;" /><p>因为子图中的栅格可能不只被一帧雷达扫描点所覆盖，所以需要对栅格的状态进行迭代更新，具体分两种情况处理。</p><p>情况1： 在当前帧的 ${M_{old}}$ 中，如果该栅格之前未被扫到（未知状态），那么直接用式 $(2-1)$ 进行更新。其中 $P_{hit},P_{miss}$ 由雷达概率观测模型给出。<br>$$<br>M_{\text{new}}(x) =<br>\begin{cases}<br>P_{\text{hit}}, &amp; \text{当 } \text{state}(x) = \text{hit} \text{ 时} \<br>P_{\text{miss}}, &amp; \text{当 } \text{state}(x) = \text{miss} \text{ 时}<br>\end{cases}<br>\tag{2-1}<br>$$<br>情况2：在当前帧的 ${M_{old}}$ 中。如果该栅格之前已经被扫到，也就是已经有取值 $M_{old}$ ，那就用式 $(2-2)$ 更新。其中 $odds$ 是一个反比例函数，$clamp$ 是一个区间限定函数。<br>$$<br>M_{\text{new}}(x) =<br>\begin{cases}<br>{clamp(odds}^{-1}({odds}(M_{\text{old}}(x)) \cdot {odds}(P_{\text{hit}}))), &amp; \text{当 } {state}(x) = \text{hit} \text{ 时} \<br>{clamp(odds}^{-1}({odds}(M_{\text{old}}(x)) \cdot {odds}(P_{\text{miss}}))), &amp; \text{当 } \text{state}(x) = \text{miss} \text{ 时}<br>\end{cases}<br>\tag{2-2}<br>$$<br>其中，$odds(prob) = \frac{prob}{1 - prob}$。</p><p>Cartographer采用这种栅格更新机制，可以有效降低环境中动态障碍物的干扰。例如建图过程中存在一个移动物体，物体被雷达扫描的位置每次都不同，假如前一个栅格 $x$ 出现了物体，$M_{old}$ 会被$P_{hit}$ 赋予初值，而下一时刻物体移出了该栅格，该栅格会被标志为非占据状态，用 $P_{miss}$ 来更新，概率取值就变小了。随着次数越来越多，概率趋于0，动态障碍物就被清除了。</p><p>上面讨论的操作是基于雷达位姿误差较小的前提。由于从运动观测模型获得的机器人位姿存在较大误差，所以需要先用观测数据对这个观测位姿做进一步更新，以更新后的位姿为基准将观测加入地图。 Cartographer 采用了 Scan-to-map matching 方法对雷达位姿进行局部优化，具体过程如下。</p><p>在将新雷达数据加入子图前，现在运动预测出的雷达位姿附近窗口内进行搜索匹配，如式 $(3)$ 。其实就是一个非线性最小二乘问题，Cartographer 采用了自家的 Ceres 非线性优化工具来求解。而式中的约束量有函数 $M_\text{smooth}$ 构建， $M_\text{smooth}$ 是一个双立方差值，也叫平滑，其实就是用来确定雷达扫描轮廓与局部子图之间的匹配度的，取值在 0 到 1 之间。<br>$$<br>\underset{\xi}{\text{argmin}} \sum_{k=1}^K(1-M_\text{smooth} (T_{\xi}\cdot h_k))^2 \tag{3}<br>$$</p><h2 id="闭环检测">闭环检测</h2><p>上面的局部建图过程采用了式 $(3)$ 对位姿 $ \xi$ 进行局部优化，有效降低了局部建图中的累积误差。但随着建图规模扩大，累积误差还是会很多，也就是地图很大时，构建的地图会出现重影的现象，如下图所示。</p><img src="https://pic.imgdb.cn/item/676515b7d0e0a243d4e6e678.jpg" alt="地图重影" style="zoom:50%;" /><p>其实就是机器人在运动了很远的距离后回到之前走过的地方，由于局部建图位姿存在累积误差，导致当前位姿和上一次走过这里的位姿不重合。位姿不重合就导致局部子图不重合，即出现重影。借助闭环检测，可以检测机器人位姿闭环这一情况，将闭环约束加入整个建图约束中，并对全局位姿进行一次全局优化，这样就能得到全局建图结果。</p><p>在局部建图过程中，使用了 Scan-to-map matching 方法进行位姿的局部优化，而闭环检测中，搜索区域的窗口会更大，位姿精度要求更高，需要采用计算效率和精度更高的搜索匹配算法。</p><p>首先看一下回环检测问题的数学表达，如式 $(4)$ 所示。式中的 $M_{nearest}$ 函数值其实就是雷达数据点 $T_{\xi} \cdot h_k$ 覆盖的栅格对应的概率取值，当搜索结果 $\xi$ 就是当前帧雷达位姿真实位姿时，当前帧雷达轮廓与地图匹配度很高（即雷达数据点覆盖的栅格都是有障碍物的），每个  $M_{nearest}$ 函数值都很大，那整个求和结果也是最大。<br>$$<br>\xi^*=\underset{\xi \in W}{\text{argmax}}\sum_{k=1}^K M_{\text{nearest}}(T_{\xi} \cdot h_k)  \tag{4}<br>$$<br>针对式 $(4)$ 所示的求最值问题，最简单的方法是在窗口 $W$  内暴力搜索。每一步搜索需要用式 $(5)$ 计算匹配得分。但当窗口比较大，而搜索步长很小时（精度要求高），并且每步都需要计算 $ K$ 维数据的求和运算，计算量会非常大，无法在机器人中做实时计算。这种暴力搜索就是 Pixel-accurate scan matching 方法。</p><p><img src="https://pic.imgdb.cn/item/67651f0fd0e0a243d4e6f094.png" alt="2"></p><p>用直接的暴力搜索来做闭环检测显然不行，因此谷歌在 Cartographer 中采用了分支定界法来提高搜索匹配效率。分支定界法简单点说，就是先以低分辨率的地图就行匹配，然后逐步提高分辨率。过程如下图所示。不过不同的是，下图所示的分支定界策略属于广度优先搜索，而 Cartographer 中用到的是深度优先搜索。</p><p><img src="https://pic.imgdb.cn/item/676520f9d0e0a243d4e6f1bd.jpg" alt="3"></p><h2 id="全局建图">全局建图</h2><p>闭环检测是在程序后台持续运行的，传感器每输入一帧雷达数据，都要对其进行闭环检测。当闭环检测中匹配得分超过设定阈值就判断闭环，将闭环约束加入到整个建图约束中，并对全局位姿约束进行一次全局优化，这样就得出全局建图结果。</p><p>在 Cartographer中采用的是稀疏位姿图来做全局优化，稀疏位姿图的约束关系可以从雷达扫描帧、局部子图、全局地图之间的位姿约束来构建。所有雷达扫描帧对应的机器人全局位姿 $\Xi<sup>s={\xi_j</sup>s}(j=1,2,\cdots,n)$ 和所有局部子图对应的全局位姿  $\Xi<sup>m={\xi_i</sup>m}(i=1,2,\cdots,m)$ 通过 Scan-to-map matching 产生的局部位姿 $\xi_{ij}$ 进行关联，数学表示如式 $(6)$ 所示。</p><p><img src="https://pic.imgdb.cn/item/676524fed0e0a243d4e6f4d7.png" alt="4"></p><p>式 $(6)$ 中，$j$ 是雷达扫描帧序号，$i$ 是子图的序号。而雷达扫描数据在局部子图中还具有局部位姿，比如 $\xi_{ij}$ 表示序号为 $j$ 的雷达扫描帧在序号 $i$ 的局部子图中的局部位姿。而损失函数 $\rho$ 用于惩罚过大误差项，比如 $\text{Huber}$ 损失函数。当检测到闭环时，对整个位姿图中所有的位姿量进行全局优化，那么 $\Xi<sup>s和\Xi</sup>m$ 中的所有位姿都会得到修正，每个位姿上对应的地图点也得到修正，这就是全局建图。</p>]]></content>
      
      
      <categories>
          
          <category> SLAM 学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Gmapping</title>
      <link href="/2024/11/20/GMapping/"/>
      <url>/2024/11/20/GMapping/</url>
      
        <content type="html"><![CDATA[<h1>激光SLAM Gmapping</h1><h2 id="Gmapping原理分析">Gmapping原理分析</h2><p>首先回顾一下SLAM问题的表示：</p><ul class="lvl-0"><li class="lvl-2"><p>贝叶斯网络表示（条件概率） ，求解：卡尔曼滤波、粒子滤波</p></li><li class="lvl-2"><p>因子图表示（最小二乘），求解：梯度下降法、高斯牛顿法</p></li><li class="lvl-2"><p>机器学习表示（神经网课），求解：神经网络训练</p></li></ul><p>而Gmapping是一种基于粒子滤波的算法。不过在Gmapping算法中，对 RBPF（Rao-BlackwellizationParticleFilte）的建议分布和重采样进行了改进。</p><h3 id="RBPF-的滤波过程">RBPF 的滤波过程</h3><p>RBPF 的思想就是将 SLAM 中的定位和建图问题分开来处理，先利用$P(x_{1:t} \mid z_{1:t},u_{1:t-1} )$估计出机器人的轨迹$x_{1:t}$，然后在轨迹已知的情况下很容易估计出地图 $m$。公式如下：<br>$$<br>P\left(x_{1:t},m \mid z_{1:t}, u_{1:t} \right)=P\left( m \mid x_{1:t},z_{1:t} \right) \cdot P\left( x_{1:t} \mid z_{1:t},u_{1:t-1}\right) \tag{1}<br>$$<br>在给定机器人位资的情况下，利用$P( m \mid x_{1:t},z_{1:t} )$ 建图很简单。RBPF 讨论的重点是$P( x_{1:t} \mid z_{1:t},u_{1:t-1})$ 定位问题的具体求解过程，一种流行的粒子滤波算法是 SIR（sampling importance resampling）滤波器。下面介绍基于 SIR 的RBPF 滤波过程。</p><h4 id="采样">采样</h4><p>新的粒子点集 ${x_{1:t}^{(i)} }$ 由上一个时刻粒子点集${x_{1:t-1}^{(i)} }$ 在建议分布 $\pi$ 里采样得到。通常把机器人概率运动模型作为建议分布，这样新的粒子点集  ${x_{t}^{(i)} }$ 的生成过程就可以表示成<br>$$<br>x_{t}^{(i)} \sim P ( x_{1:t} \mid x_{t-1}^{(i)},u_{t-1}) \tag{2}<br>$$</p><h4 id="重要性权重">重要性权重</h4><p>考虑整个运动过程，机器人每条可能得轨迹都可以用一个粒子点$x_{1:t}^{(i)}$ 表示，那么每条轨迹对应粒子点的重要性权重可以表示为<br>$$<br>w_{i}^{(i)} = \frac{ P\left( x_{1:t}^{(i)} \mid z_{1:t},u_{1:t-1} \right)}{ \pi\left( x_{1:t}^{(i)} \mid z_{1:t},u_{1:t-1} \right)}  \tag{3}<br>$$<br>其中分子是目标分布，分母是建议分布，重要性权重反应了建议分布和目标分布的差异性。</p><h4 id="重采样">重采样</h4><p>新生成的粒子点需要利用重要性权重进行替换，这就是重采样。由于粒子点总量保持不变，当权重比较小的粒子点被删除后，权重大的粒子点需要进行复制以保持粒子总量不变。经过重采样后粒子点的权重都变成一样，接着进行下一轮采样和重采样。</p><h4 id="地图估计">地图估计</h4><p>在每条轨迹对用粒子点$x_{1:t}^{(i)}$ 的条件下，都可以用 $P( m^{(i)} \mid x_{1:t}^{(i)},z_{1:t} )$  计算出一幅地图$m^{(i)}$，然后将每个轨迹计算出的地图整合就得到最终地图 $m$。</p><p>从重要性权重的公式中会发现一个明显的问题，不管当前获取的观测$z_i$ 是否有效，都要计算一次整个轨迹的权重，而且随着时间的推移，轨迹将变得很长，计算整个轨迹的权重的计算量会越来越大。将原来的重要性权重公式进行适当推导，得到权重的递归计算方法：<br>$$<br>\begin{align*}<br>w_t^{(i)} &amp;= \frac{P(x_{1:t}^{(i)} \mid z_{1:t}, u_{1:t-1})}{\pi(x_{1:t}^{(i)} \mid z_{1:t}, u_{1:t-1})} \<br>&amp;= \frac{P(z_t \mid x_{1:t}^{(i)}, z_{1:t-1}) P(x_{1:t}^{(i)} \mid z_{1:t-1}, u_{1:t-1}) / P(z_t \mid z_{1:t-1}, u_{1:t-1})}{\pi(x_{1:t}^{(i)} \mid x_{1:t-1}^{(i)}, z_{1:t}, u_{1:t-1}) \pi(x_{1:t-1}^{(i)} \mid z_{1:t-1}, u_{1:t-2})} \  \tag{4}<br>&amp;= \frac{P(z_t \mid x_{1:t}^{(i)}, z_{1:t-1}) P(x_t^{(i)} \mid x_{1:t-1}^{(i)}, u_{1:t-1}) P(x_{1:t-1}^{(i)} \mid z_{1:t-1}, u_{1:t-2}) \eta}{\pi(x_t^{(i)} \mid x_{1:t-1}^{(i)}, z_{1:t}, u_{1:t-1}) \pi(x_{1:t-1}^{(i)} \mid z_{1:t-1}, u_{1:t-2})} \<br>&amp;\propto \frac{P(z_t \mid m_{t-1}^{(i)}, x_t^{(i)}) P(x_t^{(i)} \mid x_{t-1}^{(i)}, u_{t-1})}{\pi(x_t^{(i)} \mid x_{1:t-1}^{(i)}, z_{1:t}, u_{1:t-1})} \cdot w_{t-1}^{(i)}<br>\end{align*}<br>$$<br>其中，$η=1/P(z_t∣z_{1:t−1},u_{1:t−1})$。</p><h3 id="RBPF-的建议分布改进">RBPF 的建议分布改进</h3><p>上面递归计算权重的公式中建议分布 $\pi$ 最直观的形式就是采用运动模型来计算，那当前时刻粒子点集 ${x_{1:t}^{(i)} }$  的生成及对应权重的计算方式就变为：</p><p>$$<br>\begin{align*}<br>&amp;x_{t}^{(i)} \sim P(x_{t} \mid x_{t-1}^{(i)},u_{t-1}) \ \<br>&amp;w_{t}^{(i)} \propto \frac{P(z_{t} \mid m_{t-1}<sup>{(i)},x_{t}</sup>{(i)}) P(x_t^{(i)} \mid x_{t-1}<sup>{(i)},u_{t-1})}{P(x_t</sup>{(i)} \mid x_{t-1}^{(i)},u_{t-1})} \cdot w_{t-1}^{(i)}=P(z_t \mid m_{t-1}<sup>{(i)},x_t</sup>{(i)}) \cdot w_{t-1}^{(i)} \tag{5}<br>\end{align*}<br>$$</p><p>但直接采用运动模型作为建议分布存在一些问题。如图 a）、图 b）所示，当观测数据可靠性比较低时（即观测分布的区间$L<sup>{(i)}$比较大），利用运动模型采样生成的新粒子落在区间$L</sup>{(i)}$内的数量比较多（即可采用的新粒子比较多）；而当观测数据可靠性比较高时（即观测分布的区间$L<sup>{(i)}$比较小），采样生成的新粒子落在区间$L</sup>{(i)}$内的数量比较少。由于粒子滤波是采用有限个粒子点近似表示连续空间的分布情况，因此观测分布区间内粒子点较少时，会降低观测更新过程的精度。</p><p><img src="https://pic.imgdb.cn/item/6760f64fd0e0a243d4e51071.jpg" alt="观测可靠性"></p><p>因此，观测更新过程可以分为 2 种情况来处理，当观测可靠性较低时，采用式 $(4)$ 所示的默认运动模型生成新粒子点集 ${x_{t}^{(i)} }$  及对应权重；当观测可靠性较高时，就直接从观测分布区间 $L^{(i)}$ 内采样，并将采样点集 ${x_k }$ 的分布近似为高斯分布，利用 ${x_k}$ 可以计算出该高斯分布的参数  $\mu_t^{(i)}$ 和 $\sum_t^{(i)}$ ，最后采用该高斯分布 $x_t^{(i)} \sim N(\mu_t<sup>{(i)},\sum_t</sup>{(i)})$ 采样生成新粒子点集及对应权重。</p><p>判断观测更新过程采用哪种方式很简单，首先利用运动模型推算出粒子点的新位姿 $x_t^{‘(i)}$ ，然后在 $x_t^{’(i)}$ 附近区域搜索，计算观测 $z_i$ 与已有地图 $m_{t-1}^{(i)}$ 的匹配度，当搜索区域存在 $\hat{x}<em>t^{(i)}$ 使得匹配度很高时，即可认为观测可靠性高，具体如下：<br>$$<br>\begin{align*}<br>&amp;x_t^{\prime(i)} = x</em>{t-1}^{(i)} \oplus u_{t-1} \<br>&amp;\hat{x}<em>t^{(i)} = \arg\max_x P(x \mid m</em>{t-1}^{(i)}, z_t, x_t^{\prime(i)}) \tag{6}<br>\end{align*}<br>$$<br>下面就具体讨论观测可靠性高的情况。观测分布的区间 $L^{(i)}$ 的范围可以定义为 $L^{(i)}={x \mid P(z_t \mid m_{t-1}^{(i)},x)&gt;\varepsilon}$ ，搜索出的匹配度最高的位姿点 $\hat{x}<em>t^{(i)}$ 其实就是区间 $L^{(i)}$  概率峰值区域。以 $\hat{x}<em>t^{(i)}$ 为中心、以 $\Delta$ 为半径的区域内随机采固定数量的 $K$ 个点 ${x_k}$ ，其中每个点的采样如下：<br>$$<br>x_k \sim { x_j \mid ||x_j-\hat{x}<em>t^{(i)}|| &lt; \Delta} \tag{7}<br>$$<br>将采样点集 ${x_k}$ 近似为高斯分布，并将运动和观测信息都考虑进来，就可以通过 ${x_k}$ 计算该高斯分布的参数  $\mu_t^{(i)}$ 和 $\sum_t^{(i)}$ ，如下：<br>$$<br>\begin{align*}<br>&amp;\mu_t^{(i)} = \frac{1}{\eta^{(i)}} \sum</em>{j=1}^{K} x_j \cdot P(z_t \mid m</em>{t-1}^{(i)}, x_j) P(x_j \mid x</em>{t-1}^{(i)}, u_{t-1}) \<br>&amp;\Sigma_t^{(i)} = \frac{1}{\eta^{(i)}} \sum_{j=1}^{K} (x_j - \mu_t^{(i)}) (x_j - \mu_t<sup>{(i)})</sup>T \cdot P(z_t \mid m_{t-1}^{(i)}, x_j) P(x_j \mid x_{t-1}^{(i)}, u_{t-1}) \tag{8}<br>\end{align*}<br>$$<br>其中 $η^{i} = \sum\limits_{j=1}^KP(z_i \mid m_{t-1}^{(i)},x_j)P(x_j \mid x_{t-1}^{(i)},u_{t-1}) $。</p><p>因此，新粒子点集 ${ x_t^{(i)}}$ 将从高斯分布 $x_t^{(i)}\sim N(\mu_t<sup>{(i)},\sum_t</sup>{(i)})$ 中采样生成，而式$(4)$ 中的建议分布 $\pi$ 采用改进建议分布 $P(x_t^{(i)} \mid m_{t-1}<sup>{(i)},x_{t-1}</sup>{(i)},z_t,u_{t-1})$ 来计算，那么当前时刻粒子点集 ${x_t^{(i)}}$ 的生成及对应权重的计算方式就变成：<br>$$<br>\begin{align*}<br>&amp;x_t^{(i)} \sim N(\mu_t^{(i)}, \Sigma_t^{(i)}) \<br>w_t^{(i)} &amp;\propto \frac{P(z_t \mid m_{t-1}^{(i)}, x_t^{(i)}) P(x_t^{(i)} \mid x_{t-1}^{(i)}, u_{t-1})}{P(x_t^{(i)} \mid m_{t-1}^{(i)}, x_{t-1}^{(i)}, z_t, u_{t-1})}\cdot w_{t-1}^{(i)}\<br>&amp;= \frac{P(z_t \mid m_{t-1}^{(i)}, x_t^{(i)}) P(x_t^{(i)} \mid x_{t-1}^{(i)}, u_{t-1})}{P(z_t \mid m_{t-1}^{(i)}, x_t^{(i)}) P(x_t^{(i)} \mid x_{t-1}^{(i)}, u_{t-1}) / P(z_t \mid m_{t-1}^{(i)}, x_{t-1}^{(i)},u_{t-1})}\cdot w_{t-1}^{(i)}\ \tag{9}<br>&amp;=w_{t-1}^{(i)}\cdot P(z_t\mid m_{t-1}<sup>{(i)},x_{t-1}</sup>{(i)},u_{t-1}) \<br>&amp;= w_{t-1}^{(i)} \cdot \int P(z_t \mid x’) P(x’ \mid x_{t-1}^{(i)}, u_{t-1}) dx’ \<br>&amp;\approx w_{t-1}^{(i)} \cdot \sum_{j=1}^{K} P(z_t \mid m_{t-1}^{(i)}, x_j) P(x_j \mid x_{t-1}^{(i)}, u_{t-1})\<br>&amp;= w_{t-1}^{(i)} \cdot \eta^{(i)}<br>\end{align*}<br>$$</p><h3 id="RBPF的重采样改进">RBPF的重采样改进</h3><p>生成新的粒子点集 ${x_t^{(i)}}$ 及对应权重后，就可以进行重采样了。如果每更新一次粒子点集，都要利用权重进行重采样，那当粒子点权重在更新过程中变化不是特别大，或者由于噪声使得某些坏粒子点比好粒子点的权重还要大时，此时执行重采样就会导致好粒子点的丢失。所以在执行重采样前，必须要确保其有效性，改进的重采样策略通过式 $(10)$ 所示参数来衡量有效性。其中 $\tilde{w}^{(i)}$ 是粒子的归一化权重，当建议分布与目标分布之间的近似度高时，各个粒子点的权重都很相近；而当建议分布与目标分布之间的近似度低时，各个粒子点的权重差异较大。也就是说可以用某个阈值来判断参数 $N_{eff}$ 的有效性，当 $N_{eff}$ 小于阈值时就执行重采样，否则跳过重采样。<br>$$<br>N_{eff} = \frac{1}{\sum\limits_{i=1}<sup>{N}(\tilde{w}</sup>{(i)})^2} \tag{10}<br>$$</p><h3 id="改进RBPF的滤波过程">改进RBPF的滤波过程</h3><p>下面代码为改进 RBPF 实现 Gmapping 算法的伪代码。</p><img src="https://pic.imgdb.cn/item/67614e82d0e0a243d4e56eca.jpg" alt="扫描全能王 2024-12-14 17.25_1_edit_379095038057778" style="zoom:50%;" /><img src="https://pic.imgdb.cn/item/67614e6ed0e0a243d4e56eb1.jpg" alt="伪代码" style="zoom: 50%;" /><h2 id="Gmapping源码分析">Gmapping源码分析</h2><h3 id="代码框架">代码框架</h3><img src="https://pic.imgdb.cn/item/67614e5dd0e0a243d4e56e9b.jpg" alt="代码框架" style="zoom:50%;" /><p>Gmapping 算法用了两个功能包来组织代码，分别是slam_gmapping和openslam_gmapping，其中slam_gmapping用于实现算法的 ROS 相关接口，具体实现在 gmapping 子功能包中；而 openslam_gmapping用于实现建图核心算法，也就是粒子滤波的具体实现。</p><h3 id="程序调用流程">程序调用流程</h3><img src="https://pic.imgdb.cn/item/676136a8d0e0a243d4e52f79.png" alt="程序调用"  />]]></content>
      
      
      <categories>
          
          <category> SLAM 学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基于因子图的状态估计</title>
      <link href="/2024/10/08/%E5%9F%BA%E4%BA%8E%E5%9B%A0%E5%AD%90%E5%9B%BE%E7%9A%84%E7%8A%B6%E6%80%81%E4%BC%B0%E8%AE%A1/"/>
      <url>/2024/10/08/%E5%9F%BA%E4%BA%8E%E5%9B%A0%E5%AD%90%E5%9B%BE%E7%9A%84%E7%8A%B6%E6%80%81%E4%BC%B0%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1>基于因子图的状态估计</h1><blockquote><p>记录学习《机器人SLAM导航核心技术与实战》的一些知识，配套教学视频：<a href="https://www.bilibili.com/video/BV1jS4y1a7Lz/?spm_id_from=333.999.0.0">《机器人SLAM导航核心技术与实战》书籍配套教学视频</a></p></blockquote><p>​虽然完全 SLAM 系统可以用滤波方法求解，比如著名的  Fast-SLAM  框架，但是贝叶斯网络表示下的完全 SLAM 系统能很方便地转换成因子图表示，这样贝叶斯网络中的最大后验估计就等效为因子图中的最小二乘估计。本节主要讨论的就是如何求解最小二乘问题（通常为非线性最小二乘问题）。</p><p>​求解非线性最小二乘问题的方法大致有两种：</p><ul class="lvl-0"><li class="lvl-2"><p>先对非线性问题进行线性化近似处理，然后直接求解线性方程来得到待估计量</p></li><li class="lvl-2"><p>不直接求解，通过迭代策略，让目标函数快速下降到最值处，对应的估计量也就求出来了</p></li></ul><p><img src="https://pic1.imgdb.cn/item/678d33e3d0e0a243d4f5b7df.png" alt="image-20241111122640547"></p><h2 id="直接求解方法">直接求解方法</h2><p>​非线性最小二乘问题表示为：</p><p>​<img src="https://pic1.imgdb.cn/item/678d33e4d0e0a243d4f5b7e1.png" alt="image-20241112164844980" style="zoom: 67%;" /></p><p>​对 ***f(x)***泰勒展开进行线性化近似，</p><p>​<img src="https://pic1.imgdb.cn/item/678d33e4d0e0a243d4f5b7e2.png" alt="image-20241112165040661" style="zoom: 67%;" /></p><p>​<img src="https://pic1.imgdb.cn/item/678d33e1d0e0a243d4f5b7d9.png" alt="image-20241112165052384" style="zoom:67%;" /></p><p>​最小二乘问题可以变为</p><p>​<img src="https://pic1.imgdb.cn/item/678d33e2d0e0a243d4f5b7da.png" alt="image-20241112165202146" style="zoom:67%;" /></p><p>​上式在理想情况下可以取到0，即</p><p>​<img src="https://pic1.imgdb.cn/item/678d33e2d0e0a243d4f5b7db.png" alt="image-20241112165257965" style="zoom:67%;" /></p><p>​对上面线性方程求解即可。求解上面线性方程有两种方法：Cholesky分解、QR分解。</p><ul class="lvl-0"><li class="lvl-2"><p>Cholesky分解</p></li></ul><p>​<img src="https://pic1.imgdb.cn/item/678d33e2d0e0a243d4f5b7dc.png" alt="image-20241112165443865" style="zoom:67%;" /></p><ul class="lvl-0"><li class="lvl-2"><p>QR分解</p></li></ul><p>​<img src="https://pic1.imgdb.cn/item/678d33e3d0e0a243d4f5b7dd.png" alt="image-20241112165500639" style="zoom:67%;" /></p><h2 id="优化方法">优化方法</h2><p>​ 由于实际 SLAM 问题的非线性最小二乘中，很难找到合适的线性化方法，初值也比较难确定，并且代价函数的误差往往不能最小化到0值，所以上面介绍的直接求解方法很难利用在实际问题中。实际工程中，通常采用优化方法进行迭代求解。</p><p>​ 迭代策略主要有以下几种方法：</p><ul class="lvl-0"><li class="lvl-2"><p>梯度下降算法</p></li><li class="lvl-2"><p>最速下降算法</p></li><li class="lvl-2"><p>高斯-牛顿算法</p></li><li class="lvl-2"><p>列文伯格-马夸尔特算法</p></li><li class="lvl-2"><p>狗腿算法</p></li></ul><p>​具体如下：</p><p>​<img src="https://pic1.imgdb.cn/item/678d33e3d0e0a243d4f5b7de.png" alt="image-20241112165814701"></p><p>​可以发现，每一种方法都是前一种的改进，下降速度越来越好，但是每一步迭代的计算代价越来越高。</p><p>​因此，在实际应用中要结合实际问题合理选择。比如Dogleg算法虽然每步迭代下降效果是最好的，但是每步迭代付出的计算代价也最昂贵，站在整个迭代过程看，迭代效率并不一定比最普通的梯度下降法好。</p><h2 id="常用的优化工具">常用的优化工具</h2><ul class="lvl-0"><li class="lvl-2"><p>图优化工具 g2o （轻量级）</p></li><li class="lvl-2"><p>非线性优化工具 Ceres-Solver （复杂但性能强）</p></li><li class="lvl-2"><p>增量优化工具 GTSAM （精度稍低但支持增量优化）</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> SLAM 学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基于贝叶斯网络的状态估计</title>
      <link href="/2024/10/06/%E5%9F%BA%E4%BA%8E%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BD%91%E7%BB%9C%E7%9A%84%E7%8A%B6%E6%80%81%E4%BC%B0%E8%AE%A1/"/>
      <url>/2024/10/06/%E5%9F%BA%E4%BA%8E%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BD%91%E7%BB%9C%E7%9A%84%E7%8A%B6%E6%80%81%E4%BC%B0%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1>基于贝叶斯网络的状态估计</h1><blockquote><p>记录学习《机器人SLAM导航核心技术与实战》的一些知识，配套教学视频：<a href="https://www.bilibili.com/video/BV1jS4y1a7Lz/?spm_id_from=333.999.0.0">《机器人SLAM导航核心技术与实战》书籍配套教学视频</a></p></blockquote><p>​之前的相关表示和推理都是基于一般情况而言，不涉及机器人实际数据。本节引入机器人实际测量数据，并基于贝叶斯网络表示这些数据的关系。基于这种表示，状态估计很容易进行，一般采用贝叶斯估计。</p><p>​根据选取估计量不同，又分为以下几种估计问题：</p><ul class="lvl-0"><li class="lvl-2"><p>仅对机器人当前位姿状态 <img src="https://pic1.imgdb.cn/item/678d327ed0e0a243d4f5b798.png" alt="image-20241108163403164" style="zoom:50%;" /> 进行状态估计，就是定位问题，对应后验概率分布表述如下：</p></li></ul><p>​<img src="https://pic1.imgdb.cn/item/678d327ed0e0a243d4f5b799.png" alt="image-20241108163513104" style="zoom: 67%;" /></p><ul class="lvl-0"><li class="lvl-2"><p>除了当前位姿状态 <img src="https://pic1.imgdb.cn/item/678d327ed0e0a243d4f5b798.png" alt="image-20241108163403164" style="zoom:50%;" />， 同时对地图 <img src="https://pic1.imgdb.cn/item/678d327ed0e0a243d4f5b79a.png" alt="image-20241108163616400" style="zoom:67%;" />进行估计，就是在线 SLAM 问题，对应后验概率分布表述如下：</p></li></ul><p>​<img src="https://pic1.imgdb.cn/item/678d327ed0e0a243d4f5b79b.png" alt="image-20241108163721327" style="zoom:67%;" /></p><ul class="lvl-0"><li class="lvl-2"><p>对于所有历史位姿  <img src="https://pic1.imgdb.cn/item/678d327fd0e0a243d4f5b79c.png" alt="image-20241108163759887" style="zoom:67%;" /> 和地图 <img src="https://pic1.imgdb.cn/item/678d327ed0e0a243d4f5b79a.png" alt="image-20241108163616400" style="zoom:67%;" /> 同时估计，就是完全 SLAM 问题，对应后验概率分布表述如下：</p></li></ul><p>​<img src="https://pic1.imgdb.cn/item/678d327fd0e0a243d4f5b79d.png" alt="image-20241108163901098" style="zoom:67%;" /></p><p>​前两种问题求解过程都是类似的，也就是滤波方法。第三种也可以使用滤波方法求解，如著名的 Fast-SLAM 实现框架，但贝叶斯网络表示的完全 SLAM 系统可以方便转换为因子图表示，因此用因子图表示 SLAM 问题，然后使用最小二乘估计进行求解更方便。本节主要内容为前两种问题滤波方法的分析。第三种问题求解会在下节展开。</p><p><img src="https://pic1.imgdb.cn/item/678d327fd0e0a243d4f5b79e.png" alt="image-20241108164430212"></p><h2 id="贝叶斯估计">贝叶斯估计</h2><p>​以贝叶斯网络（表示）、定位（待估问题）、贝叶斯估计（求解方法）这种情况为例来讨论。</p><p>​这里使用  <img src="https://pic1.imgdb.cn/item/678d327fd0e0a243d4f5b79f.png" alt="image-20241108164739436" style="zoom:67%;" /> 表示<img src="https://pic1.imgdb.cn/item/678d3285d0e0a243d4f5b7a7.png" alt="image-20241108165355705" style="zoom:67%;" />（这里由于地图 <img src="https://pic1.imgdb.cn/item/678d327ed0e0a243d4f5b79a.png" alt="image-20241108163616400" style="zoom:67%;" /> 是常量可以忽略，将第一种问题的表示进行了化简），常称为<strong>置信度</strong>。<img src="https://pic1.imgdb.cn/item/678d3280d0e0a243d4f5b7a0.png" alt="image-20241108164916041" style="zoom: 67%;" /> 为观测数据，<img src="https://pic1.imgdb.cn/item/678d3281d0e0a243d4f5b7a1.png" alt="image-20241108164945205" style="zoom:67%;" /> 为运动数据。下图为推导过程：</p><img src="https://pic1.imgdb.cn/item/678d3284d0e0a243d4f5b7a4.png" alt="image-20241108165107516" style="zoom:80%;" /><p>​由右边两个式子可以整理得到<strong>递归贝叶斯滤波</strong>：</p><p>​<img src="https://pic1.imgdb.cn/item/678d3285d0e0a243d4f5b7a6.png" alt="image-20241108165258339" style="zoom:80%;" /></p><p>​由于后验概率分布<img src="https://pic1.imgdb.cn/item/678d3285d0e0a243d4f5b7a7.png" alt="image-20241108165355705" style="zoom:67%;" /> 没有具体形式，也就是所递归贝叶斯滤波是一种通用框架，给定不同形式的分布后，贝叶斯滤波也就对应不同形式的算法实现。下面是分类：</p><p>​<img src="https://pic1.imgdb.cn/item/678d3285d0e0a243d4f5b7a8.png" alt="image-20241108165730058" style="zoom:67%;" /></p><p>​<img src="https://pic1.imgdb.cn/item/678d3285d0e0a243d4f5b7a9.png" alt="image-20241108165757852" style="zoom:67%;" /></p><p>​下面从最简单的线性高斯系统入手，基于矩参数表示高斯分布，引出卡尔曼滤波（KF），然后讨论非线性高斯系统，引出扩展卡尔曼滤波（EKF）和无迹卡尔曼滤波（UKF）。</p><h2 id="参数化实现">参数化实现</h2><h3 id="卡尔曼滤波">卡尔曼滤波</h3><h4 id="线性卡尔曼滤波（线性高斯系统）">线性卡尔曼滤波（线性高斯系统）</h4><p>​高斯分布可以用矩参数（均值和方差）进行表示，那多维高斯分布为</p><p>​<img src="https://pic1.imgdb.cn/item/678d3286d0e0a243d4f5b7aa.png" alt="image-20241108170240461" style="zoom:80%;" /></p><p>​假设机器人的运动方程为</p><p>​<img src="https://pic1.imgdb.cn/item/678d3286d0e0a243d4f5b7ab.png" alt="image-20241108170349049" style="zoom:80%;" /></p><p>​观测方程为</p><p>​<img src="https://pic1.imgdb.cn/item/678d3286d0e0a243d4f5b7ac.png" alt="image-20241108170519088" style="zoom:80%;" /></p><p>​得到的概率运动模型为：</p><p>​<img src="https://pic1.imgdb.cn/item/678d3287d0e0a243d4f5b7ae.png" alt="image-20241108170831155" style="zoom:80%;" /></p><p>​概率观测模型为：</p><p>​<img src="https://pic1.imgdb.cn/item/678d3287d0e0a243d4f5b7af.png" alt="image-20241108170900544" style="zoom:80%;" /></p><p>​待估状态量置信度的高斯分布形式为：</p><p>​<img src="https://pic1.imgdb.cn/item/678d3287d0e0a243d4f5b7b0.png" alt="image-20241108171055411" style="zoom:80%;" /></p><p>​卡尔曼滤波其实就是利用下面五个核心公式，递归计算：</p><p><img src="https://pic1.imgdb.cn/item/678d3288d0e0a243d4f5b7b2.png" alt="image-20241108171732416"></p><h4 id="扩展卡尔曼滤波（非线性高斯系统）">扩展卡尔曼滤波（非线性高斯系统）</h4><p>​线性卡尔曼滤波假设了机器人运动方程和观测方程都是线性的，但实际上往往都是非线性的，也就是说高斯随机变量经过非线性函数变换后都将变成非高斯随机变量，因此计算过程需要先<strong>线性化近似处理</strong>。在扩展卡尔曼滤波（EKF）中，采用一阶泰勒展开对非线性函数方程进行线性化。</p><p>​对运动方程  <img src="https://pic1.imgdb.cn/item/678d3288d0e0a243d4f5b7b3.png" alt="image-20241108174439333" style="zoom: 80%;" /> 进行一阶泰勒展开得到：</p><p>​<img src="https://pic1.imgdb.cn/item/678d3288d0e0a243d4f5b7b4.png" alt="image-20241108174508667" style="zoom:80%;" /></p><p>​对观测方程 <img src="https://pic1.imgdb.cn/item/678d3289d0e0a243d4f5b7b5.png" alt="image-20241108174523144" style="zoom:80%;" /> 展开得到：</p><p>​<img src="https://pic1.imgdb.cn/item/678d3289d0e0a243d4f5b7b6.png" alt="image-20241108174547439" style="zoom:80%;" /></p><p>​进而得到概率运动模型：</p><p>​<img src="https://pic1.imgdb.cn/item/678d3289d0e0a243d4f5b7b7.png" alt="image-20241108174610874" style="zoom:80%;" /></p><p>​概率观测模型：</p><p>​<img src="https://pic1.imgdb.cn/item/678d3289d0e0a243d4f5b7b8.png" alt="image-20241108174627650" style="zoom:80%;" /></p><p>​那卡尔曼滤波的五个核心公式变为：</p><p>​<img src="https://pic1.imgdb.cn/item/678d328ad0e0a243d4f5b7b9.png" alt="image-20241108174801806" style="zoom:80%;" /></p><p>​</p><p>​<img src="https://pic1.imgdb.cn/item/678d328ad0e0a243d4f5b7bb.png" alt="image-20241108175040161" style="zoom:80%;" /></p><h4 id="无迹卡尔曼滤波（非线性高斯系统）">无迹卡尔曼滤波（非线性高斯系统）</h4><p>​ 如果 <em>x</em> 的不确定性和函数 <em>g</em> 的非线性度都小，那么扩展卡尔曼滤波（EKF）中线性化近似效果是好的。但是，当 <em>x</em> 的不确定性和函数 <em>g</em> 的非线性度较大时，扩展卡尔曼滤波（EKF）的近似效果就不好了，此时可以用无迹卡尔曼滤波（UKF）来处理。</p><p>​无迹卡尔曼滤波中采用的线性化技术也叫无迹变换。选取高斯分布 <em>P(X)</em> 上的 <em>σ</em> 点，然后将这些 <em>σ</em> 点经过 <em>g(x)</em> 变换，利用变换后的点推算出变换后的高斯分布均值和协方差矩阵。</p><p>​<img src="https://pic1.imgdb.cn/item/678d328bd0e0a243d4f5b7bc.png" alt="image-20241108175727542" style="zoom:80%;" /></p><h3 id="信息滤波">信息滤波</h3><h4 id="线性信息滤波（线性高斯系统）">线性信息滤波（线性高斯系统）</h4><p>​在矩参数表示的多维高斯分布中</p><p>​<img src="https://pic1.imgdb.cn/item/678d3286d0e0a243d4f5b7aa.png" alt="image-20241108170240461" style="zoom:80%;" /></p><p>​将矩参数转换成正则参数（信息矩阵和信息向量）：</p><p>​<img src="https://pic1.imgdb.cn/item/678d328bd0e0a243d4f5b7bd.png" alt="image-20241108180026146" style="zoom:80%;" /></p><p>​那么正则参数形式的多维高斯分布为：</p><p>​<img src="https://pic1.imgdb.cn/item/678d328bd0e0a243d4f5b7be.png" alt="image-20241108181223300" style="zoom:80%;" /></p><p>​矩参数和正则参数只是表示高斯分布的两种不同方式，分布的本质是一样的，因此，线性信息滤波的推导与线性卡尔曼滤波是类似的。</p><p>​<img src="https://pic1.imgdb.cn/item/678d328cd0e0a243d4f5b7c0.png" alt="image-20241108181402340" style="zoom:80%;" /></p><ul class="lvl-0"><li class="lvl-2"><p>可以发现线性卡尔曼滤波和线性信息滤波的性能是对偶的。</p></li><li class="lvl-3"><p>线性卡尔曼滤波中的运动预测是增量的，而线性信息滤波中的运动预测需要求矩阵逆运算，所以线性卡尔曼滤波在运动预测上计算效率更高。</p></li><li class="lvl-3"><p>不过，线性卡尔曼滤波中的观测更新需要求矩阵逆运算，而线性信息滤波中的观测更新是增量的，所以线性信息滤波在观测更新上计算效率更高。</p></li></ul><h4 id="扩展信息滤波（非线性高斯系统）">扩展信息滤波（非线性高斯系统）</h4><p>​对于非线性高斯系统，扩展信息滤波与扩展卡尔曼滤波是类似的，也需要对实际非线性系统进行线性化近似处理。</p><p>​<img src="https://pic1.imgdb.cn/item/678d327cd0e0a243d4f5b791.png" alt="image-20241108181624317" style="zoom:80%;" /></p><h2 id="非参数化实现">非参数化实现</h2><p>​当分布不是高斯分布这种可以使用参数描述的特殊形式时，就需要用一个无限维概率密度函数描述。下面介绍两种非参数化方法，即直方图滤波和粒子滤波。</p><img src="https://pic1.imgdb.cn/item/678d327cd0e0a243d4f5b792.png" alt="image-20241108181921687" style="zoom:80%;" /><h3 id="直方图滤波">直方图滤波</h3><p>​可以认为是用<strong>区域划分</strong>方法对待估量的状态空间进行离散化，用每个划分区域上质心的概率代表整个区域的概率大小。</p><p>​离散化的概率运动模型：</p><p>​<img src="https://pic1.imgdb.cn/item/678d327cd0e0a243d4f5b793.png" alt="image-20241108182055364" style="zoom:80%;" /></p><p>​离散化的概率观测模型：</p><p>​<img src="https://pic1.imgdb.cn/item/678d327dd0e0a243d4f5b794.png" alt="image-20241108182246670" style="zoom:80%;" /></p><p>​将递归贝叶斯滤波离散化（遍历待估状态的所有离散区域）后得到：</p><p>​<img src="https://pic1.imgdb.cn/item/678d327dd0e0a243d4f5b795.png" alt="image-20241108182320368" style="zoom:80%;" /></p><p>​</p><p>​<img src="https://pic1.imgdb.cn/item/678d327dd0e0a243d4f5b796.png" alt="image-20241108182421731" style="zoom:80%;" /></p><h3 id="粒子滤波">粒子滤波</h3><p>​可以认为是用<strong>随机粒子点</strong>对待估量的状态空间进行离散化，用粒子点的稠密度代表该取值空间处的概率大小。</p><p>​   <img src="https://pic1.imgdb.cn/item/678d327dd0e0a243d4f5b797.png" alt="image-20241108182642800" style="zoom:80%;" /></p>]]></content>
      
      
      <categories>
          
          <category> SLAM 学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SLAM估计理论</title>
      <link href="/2024/10/03/SLAM%E4%BC%B0%E8%AE%A1%E7%90%86%E8%AE%BA/"/>
      <url>/2024/10/03/SLAM%E4%BC%B0%E8%AE%A1%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<p>SLAM估计理论</p><blockquote><p>记录学习《机器人SLAM导航核心技术与实战》的一些知识，配套教学视频：<a href="https://www.bilibili.com/video/BV1jS4y1a7Lz/?spm_id_from=333.999.0.0">《机器人SLAM导航核心技术与实战》书籍配套教学视频</a></p></blockquote><p>​不管是用贝叶斯网络还是因子图，SLAN问题用概率图模型得到表示后，接下来就是用<strong>可观测量推理不可观测量</strong>，也就是说SLAM问题求解过程是一个<strong>状态估计</strong>。</p><h2 id="估计量的性质">估计量的性质</h2><h3 id="一致性">一致性</h3><p>从强到弱：</p><ul class="lvl-0"><li class="lvl-2"><p>依概率1收敛（几乎处处收敛）：<img src="https://pic1.imgdb.cn/item/678d30bfd0e0a243d4f5b765.png" alt="image-20241030224245858" style="zoom: 33%;" /></p></li><li class="lvl-2"><p>依概率收敛（测度收敛）：<img src="https://pic1.imgdb.cn/item/678d30c0d0e0a243d4f5b767.png" alt="image-20241030224335156" style="zoom: 33%;" /></p></li><li class="lvl-2"><p>依分布收敛：<img src="https://pic1.imgdb.cn/item/678d30c0d0e0a243d4f5b768.png" alt="image-20241030224412417" style="zoom:33%;" /></p></li><li class="lvl-2"><p>依范数收敛：<img src="https://pic1.imgdb.cn/item/678d30c0d0e0a243d4f5b769.png" alt="image-20241030224432552" style="zoom:33%;" /></p></li></ul><h3 id="偏差性">偏差性</h3><ul class="lvl-0"><li class="lvl-2"><p>无偏估计：<img src="https://pic1.imgdb.cn/item/678d30c1d0e0a243d4f5b76a.png" alt="image-20241030224533324" style="zoom: 50%;" /></p></li><li class="lvl-2"><p>最小方差估计，方差越小估计不确定性越小</p></li></ul><h2 id="估计量的构建">估计量的构建</h2><p>​ 实际情况，观测到的样本数量不可能无穷多，因此一致性只是理论上需要满足的条件。在样本数量有限时，讨论估计值与实际值之间的偏差将更有意义，也就是偏差性。所以估计策略的目标是让估计量的偏差量尽量小，最小方差无偏估计无疑是一个理想的估计量。然而，最小方差无偏估计实现非常困难，因此需要寻找近似策略.</p><h3 id="最大似然估计（MLE）">最大似然估计（MLE）</h3><p>​<img src="https://pic1.imgdb.cn/item/678d30c1d0e0a243d4f5b76b.png" alt="image-20241030224644697" style="zoom:50%;" /></p><p>​ 最大似然估计假设概率分布模型是知道的，只是概率分布模型中的参数θ未知。尝试θ的不同取值，看模型是否能输出与观测结果一样的数据。当某个θ取值能让模型输出与观测结果一样的数据的概率最大，那么这个θ取值就是最适合的估计参数。</p><h3 id="最小二乘估计（LSE）">最小二乘估计（LSE）</h3><p>​<img src="https://pic1.imgdb.cn/item/678d30c1d0e0a243d4f5b76c.png" alt="image-20241030224724912" style="zoom:50%;" /></p><p>​最小二乘估计是计算观测样本点与模型实际点之间的平方误差，求使得该平方误差最小的参数值θ，求出来的这个参数值θ就是估计参数.</p><h3 id="贝叶斯估计（Bayes）">贝叶斯估计（Bayes）</h3><p>​<img src="https://pic1.imgdb.cn/item/678d30c1d0e0a243d4f5b76d.png" alt="image-20241030224804930" style="zoom:50%;" /></p><p>​贝叶斯估计首先也是构建关于误差的代价函数，然后最小化代价函数在概率密度下的期望.</p><p>​可以看出，贝叶斯估计中的C(e)是关于误差e的抽象函数，也就是说贝叶斯估计是一个通用的形式，具体的估计量形式与函数C(e)的具体实现有关。最小均方误差估计和最大后验估计，就是贝叶斯估计的常见形式。</p><h4 id="最小均方误差估计（MMSE）">最小均方误差估计（MMSE）</h4><p>​<img src="https://pic1.imgdb.cn/item/678d30c2d0e0a243d4f5b76f.png" alt="image-20241030225040542" style="zoom:50%;" /></p><p>​化简后：</p><p>​<img src="https://pic1.imgdb.cn/item/678d30c2d0e0a243d4f5b770.png" alt="image-20241030225104190" style="zoom:50%;" /></p><h4 id="最大后验估计（MAP）">最大后验估计（MAP）</h4><p>​<img src="https://pic1.imgdb.cn/item/678d30c2d0e0a243d4f5b771.png" alt="image-20241030225127421" style="zoom:50%;" /></p><p>​化简后：</p><p>​<img src="https://pic1.imgdb.cn/item/678d30c3d0e0a243d4f5b772.png" alt="image-20241030225212080" style="zoom: 50%;" /></p><h2 id="各估计量等价转换关系">各估计量等价转换关系</h2><img src="https://pic1.imgdb.cn/item/678d30c3d0e0a243d4f5b774.png" alt="image-20241030225531570" style="zoom:67%;" />]]></content>
      
      
      <categories>
          
          <category> SLAM 学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SLAM概率理论</title>
      <link href="/2024/10/02/SLAM%E6%A6%82%E7%8E%87%E7%90%86%E8%AE%BA/"/>
      <url>/2024/10/02/SLAM%E6%A6%82%E7%8E%87%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1>SLAM概率理论</h1><blockquote><p>记录学习《机器人SLAM导航核心技术与实战》的一些知识，配套教学视频：<a href="https://www.bilibili.com/video/BV1jS4y1a7Lz/?spm_id_from=333.999.0.0">《机器人SLAM导航核心技术与实战》书籍配套教学视频</a></p></blockquote><p>​机器人问题中存在不确定性，包括传感器测量噪声、电机控制偏差、计算机软件计算精度近似等等。利用概率描述机器人中的不确定性，这样机器人中的不确定性就可以在概率理论框架下被计算和推演，即所谓的概率机器人学。下图是一个经典的例子。</p><img src="https://pic1.imgdb.cn/item/678d2d6dd0e0a243d4f5b727.png" alt="image-20241030185552839" style="zoom: 33%;" /><h2 id="状态估计问题">状态估计问题</h2><ul class="lvl-0"><li class="lvl-2"><p>状态（感兴趣的物理量）</p><ul class="lvl-2"><li class="lvl-4">直接状态</li><li class="lvl-4">间接状态</li></ul></li><li class="lvl-2"><p>估计（猜测）</p><ul class="lvl-2"><li class="lvl-4">猜测方法（概率理论）</li><li class="lvl-4">猜测依据（观测数据）</li></ul></li></ul><p>​不能直接准确测量的物理量就需要进行状态估计。</p><p>​状态估计问题在SLAM中的体现：</p><img src="https://pic1.imgdb.cn/item/678d2d6dd0e0a243d4f5b72a.png" alt="image-20241030190634546" style="zoom:67%;" /><p>​概率描述：</p><img src="https://pic1.imgdb.cn/item/678d2d6ed0e0a243d4f5b72c.png" alt="image-20241030190649256" style="zoom:67%;" /><h2 id="概率运动模型">概率运动模型</h2><h3 id="速度运动模型">速度运动模型</h3><img src="https://pic1.imgdb.cn/item/678d2d6ed0e0a243d4f5b72d.png" alt="image-20241030191111725" style="zoom:50%;" /><p>​状态转移方程：</p><img src="https://pic1.imgdb.cn/item/678d2d6ed0e0a243d4f5b72f.png" alt="image-20241030191213093" style="zoom: 80%;" /><p>​误差描述：</p><img src="https://pic1.imgdb.cn/item/678d2d6fd0e0a243d4f5b732.png" alt="image-20241030191444950" style="zoom: 67%;" /><h3 id="里程计运动模型">里程计运动模型</h3><img src="https://pic1.imgdb.cn/item/678d2d6fd0e0a243d4f5b734.png" alt="image-20241030191542869" style="zoom:50%;" /><p>​状态转移方程：</p><img src="https://pic1.imgdb.cn/item/678d2d6fd0e0a243d4f5b736.png" alt="image-20241030191608931" style="zoom:67%;" /><p>​误差描述：</p><img src="https://pic1.imgdb.cn/item/678d2d70d0e0a243d4f5b737.png" alt="image-20241030191648759" style="zoom:67%;" /><h2 id="概率观测模型">概率观测模型</h2><h3 id="激光">激光</h3><h4 id="波束模型">波束模型</h4><img src="https://pic1.imgdb.cn/item/678d2d70d0e0a243d4f5b738.png" alt="image-20241030192229260" style="zoom:67%;" /><p>波束模型缺乏光滑性，导致构建的地图具有很多毛刺。</p><h4 id="似然域模型">似然域模型</h4><img src="https://pic1.imgdb.cn/item/678d2d70d0e0a243d4f5b739.png" alt="image-20241030192301892" style="zoom:67%;" /><p>似然域模型较为光滑，构建的地图不易出现毛刺。</p><p>两个模型都是 大量实践数据归纳总结出来的。</p><h2 id="概率图模型">概率图模型</h2><p>​利用概率图模型来描述运动模型与观测模型之间的概率关系。</p><img src="https://pic1.imgdb.cn/item/678d2d70d0e0a243d4f5b73a.png" alt="image-20241030212121756" style="zoom:50%;" /><p>​概率图模型分类：</p><img src="https://pic1.imgdb.cn/item/678d2d71d0e0a243d4f5b73b.png" alt="image-20241030212218847" style="zoom:67%;" /><h3 id="贝叶斯网络">贝叶斯网络</h3><h4 id="模型">模型</h4><ol><li class="lvl-3"><p>模型如图所示，箭头表示随机变量之间依赖的因果关系。</p></li></ol><img src="https://pic1.imgdb.cn/item/678d2d71d0e0a243d4f5b73c.png" alt="image-20241030212248378" style="zoom: 80%;" /><ol start="2"><li class="lvl-4"><p>联合分布</p></li></ol><p>​根据条件独立性，可以得到联合分布的化简形式：</p><p><img src="https://pic1.imgdb.cn/item/678d2d71d0e0a243d4f5b73d.png" alt="image-20241030212443265"></p><p>​联合分布化简的一般形式：</p><img src="https://pic1.imgdb.cn/item/678d2d71d0e0a243d4f5b73e.png" alt="image-20241030212530944" style="zoom: 50%;" /><h4 id="表示SLAM问题">表示SLAM问题</h4><h5 id="静态贝叶斯网络">静态贝叶斯网络</h5><ol><li class="lvl-3"><p>表示</p></li></ol><img src="https://pic1.imgdb.cn/item/678d2d72d0e0a243d4f5b73f.png" alt="image-20241030212752006" style="zoom:50%;" /><ol start="2"><li class="lvl-3"><p>学习</p></li></ol><p>​需要学习模型结构和模型参数</p><ol start="3"><li class="lvl-3"><p>推理</p></li></ol><p>​给定预测、先验信息（模型结构、参数）、预测结果</p><img src="https://pic1.imgdb.cn/item/678d2d72d0e0a243d4f5b740.png" alt="image-20241030212855453" style="zoom:50%;" /><h5 id="动态贝叶斯网络">动态贝叶斯网络</h5><ol><li class="lvl-3"><p>表示SLAM问题</p></li></ol><img src="https://pic1.imgdb.cn/item/678d2d72d0e0a243d4f5b741.png" alt="image-20241030213006209" style="zoom: 67%;" /><ol start="2"><li class="lvl-3"><p>学习</p></li><li class="lvl-3"><p>推理</p></li></ol><img src="https://pic1.imgdb.cn/item/678d2d68d0e0a243d4f5b715.png" alt="image-20241030213035125" style="zoom:67%;" /><h3 id="马尔可夫网络">马尔可夫网络</h3><ol><li class="lvl-3"><p>模型如下图所示，连线表示随机变量之间隐式相关性，可以表示循环依赖。团中的节点必须两两之间都有连接（团的定义），团的势能函数是一个抽象函数，需要在实际问题中具体化为特定形式。不能再加入节点的团是最大团。最大团之间具有条件独立性。</p></li></ol><img src="https://pic1.imgdb.cn/item/678d2d68d0e0a243d4f5b716.png" alt="image-20241030213206981" style="zoom:50%;" /><ol start="2"><li class="lvl-3"><p>联合分布</p></li></ol><p>​联合分布化简形式：</p><img src="https://pic1.imgdb.cn/item/678d2d68d0e0a243d4f5b717.png" alt="image-20241030213527864" style="zoom:80%;" /><p>​联合分布最大团化简形式</p><img src="https://pic1.imgdb.cn/item/678d2d69d0e0a243d4f5b718.png" alt="image-20241030213624656" style="zoom:67%;" /><p>​一般形式</p><img src="https://pic1.imgdb.cn/item/678d2d69d0e0a243d4f5b719.png" alt="image-20241030213645193" style="zoom: 50%;" /><h3 id="因子图">因子图</h3><h4 id="马尔可夫网络转换成因子图">马尔可夫网络转换成因子图</h4><ul class="lvl-0"><li class="lvl-2"><p>马尔可夫网络中团的势能函数只能笼统表示团内节点之间的相关性。</p></li><li class="lvl-2"><p>将团的势能函数进行因式分解，分解出来的因子项对随机变量之间的关系描述更具体。、</p></li><li class="lvl-2"><p>由于因式分解不唯一，所以马尔可夫网络到因子图的转换也不唯一。</p></li></ul><img src="https://pic1.imgdb.cn/item/678d2d69d0e0a243d4f5b71a.png" alt="image-20241030213856355" style="zoom:50%;" /><p>​联合分布因子项化简形式：</p><ul class="lvl-0"><li class="lvl-2"><img src="https://pic1.imgdb.cn/item/678d2d69d0e0a243d4f5b71b.png" alt="image-20241030214036511" style="zoom:50%;" /></li><li class="lvl-2"><img src="https://pic1.imgdb.cn/item/678d2d6ad0e0a243d4f5b71c.png" alt="image-20241030214054003" style="zoom:50%;" /></li></ul><h4 id="贝叶斯网络转换成因子图">贝叶斯网络转换成因子图</h4><p>​贝叶斯网络表示的SLAM问题：</p><img src="https://pic1.imgdb.cn/item/678d2d6ad0e0a243d4f5b71d.png" alt="image-20241030214252421" style="zoom:67%;" /><p>​将贝叶斯网络箭头的条件概率替换成因子图的最小二乘约束边，转化成最小二乘约束形式因子图表示的SLAM问题：</p><img src="https://pic1.imgdb.cn/item/678d2d6ad0e0a243d4f5b71e.png" alt="image-20241030215234739" style="zoom:67%;" /><p>​转化过程：</p><ol><li class="lvl-3"><p>假设</p><p><img src="https://pic1.imgdb.cn/item/678d2d6bd0e0a243d4f5b71f.png" alt="image-20241030215357960" style="zoom:50%;" /><img src="https://pic1.imgdb.cn/item/678d2d6bd0e0a243d4f5b720.png" alt="image-20241030215435654" style="zoom: 67%;" /></p></li><li class="lvl-3"><p>SLAM问题表示（联合分布）：</p></li></ol><img src="https://pic1.imgdb.cn/item/678d2d6bd0e0a243d4f5b721.png" alt="image-20241030215520242" style="zoom:67%;" /><ol start="3"><li class="lvl-3"><p>SLAM问题推理：</p></li></ol><p>​利用给定观测状态估计未知状态，比如最大后验估计</p><p>​<img src="https://pic1.imgdb.cn/item/678d2d6cd0e0a243d4f5b723.png" alt="image-20241030215617294" style="zoom: 50%;" /></p><p>​在获得直接量测信息U和Z后,利用条件概率分布关系对不可量测信息X和m进行推理，这就是SLAM问题的状态估计过程。</p><p>​<img src="https://pic1.imgdb.cn/item/678d2d6cd0e0a243d4f5b724.png" alt="image-20241030215636683" style="zoom:50%;" /></p><p>​由于估计过程关心的是X和M，所以可以用运动和观测这两个约束来构建因子函数，将不关心的U、Z隐藏到因子函数约束中。得到最小二乘估计：</p><p>​<img src="https://pic1.imgdb.cn/item/678d2d6cd0e0a243d4f5b725.png" alt="image-20241030215945493" style="zoom:67%;" /></p><p>​上面推导遵循以下假设：</p><ul class="lvl-0"><li class="lvl-2"><p>假设运动噪声和观测噪声都是0均值高斯分布</p></li><li class="lvl-2"><p>用运动误差和观测误差分别来构造运动约束和观测约束这2种因子项</p></li><li class="lvl-2"><p>误差项采用分布的协方差矩阵加权求和</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> SLAM 学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>初识SLAM</title>
      <link href="/2024/10/01/%E5%88%9D%E8%AF%86SLAM/"/>
      <url>/2024/10/01/%E5%88%9D%E8%AF%86SLAM/</url>
      
        <content type="html"><![CDATA[<h1>初识SLAM</h1><blockquote><p>记录学习《机器人SLAM导航核心技术与实战》的一些知识，配套教学视频：<a href="https://www.bilibili.com/video/BV1jS4y1a7Lz/?spm_id_from=333.999.0.0">《机器人SLAM导航核心技术与实战》书籍配套教学视频</a></p></blockquote><h2 id="SLAM是什么">SLAM是什么</h2><p>​ SLAM （同时定位与建图）并不仅仅指代某种特定算法，SLAM是一种问题的总称。常见的Gmapping、cartographer、LOAM、ORB-SLAM等都是SLAM的一种求解方法，也叫算法。</p><p>​目前SLAM的概念已经泛化，被定位、导航、自主移动等应用的笼统习惯指代。</p><h2 id="SLAM的起源">SLAM的起源</h2><h3 id="定位问题">定位问题</h3><ul class="lvl-0"><li class="lvl-2"><p>参考物</p></li><li class="lvl-2"><p>相对关系</p><ul class="lvl-2"><li class="lvl-4">直接<ul class="lvl-4"><li class="lvl-6">欧式坐标</li><li class="lvl-6">极坐标</li><li class="lvl-6">球坐标</li><li class="lvl-6">四叉树、八叉树</li><li class="lvl-6">······</li></ul></li><li class="lvl-4">间接<ul class="lvl-4"><li class="lvl-6">拓扑描述</li><li class="lvl-6">模糊描述</li><li class="lvl-6">······</li></ul></li></ul></li></ul><blockquote><p>定位的本质都是提前部署参考物。</p></blockquote><blockquote><p>四叉树、八叉树是对位置从大到小逐渐细分，每次细分记录目标点所在的区域，如图所示。</p><img src="https://pic1.imgdb.cn/item/678d3226d0e0a243d4f5b783.png" alt="image-20241030172152849" style="zoom: 25%;" /></blockquote><h3 id="建图问题">建图问题</h3><p>​建图的本质都是基于已知位置切片的拼接。</p><h3 id="SLAM问题">SLAM问题</h3><p>​首先对比一下定位问题和建图问题：</p><ol><li class="lvl-3"><p>定位问题：</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p>已知全局地图坐标信息</p></li><li class="lvl-2"><p>利用观测求解机器人在地图中的坐标</p></li></ul><ol start="2"><li class="lvl-3"><p>建图问题：</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p>已知机器人的实时坐标</p></li><li class="lvl-2"><p>利用观测求解被观测物体的坐标</p><p>总的来说就是定位问题<strong>依靠地图信息推测定位信息</strong>，建图问题<strong>依靠定位信息推测地图信息</strong>。</p><p>两者相互依赖，故 <strong>SLAM问题需要同时解决定位和建图两个问题</strong>。</p></li></ul><p><img src="https://pic1.imgdb.cn/item/678d3227d0e0a243d4f5b784.png" alt="image-20241030173514291"></p><h3 id="导航问题">导航问题</h3><p>​从工程上看，自主移动实质上就是解决从地点A到地点B的问题。</p><ul class="lvl-0"><li class="lvl-2"><p>我在哪？ &gt;&gt;  取决于何种坐标系</p></li><li class="lvl-2"><p>我将到哪里去？  &gt;&gt;  取决于目的地在参考系下的描述方式</p></li><li class="lvl-2"><p>我该如何去？  &gt;&gt;  取决于路线和运动方式</p></li></ul><h2 id="数据关联、收敛和一致性">数据关联、收敛和一致性</h2><h3 id="数据关联">数据关联</h3><ul class="lvl-0"><li class="lvl-2"><p>不相关（定位丢失）</p></li><li class="lvl-2"><p>部分相关（增量建图）</p></li><li class="lvl-2"><p>强相关（闭环检测/重定位）</p></li></ul><h3 id="收敛性">收敛性</h3><ul class="lvl-0"><li class="lvl-2"><p>数列收敛</p></li><li class="lvl-2"><p>级数收敛（绝对收敛、条件收敛）</p></li><li class="lvl-2"><p>函数收敛（定点收敛、无穷收敛、路径收敛）</p></li><li class="lvl-2"><p>函数序列收敛（逐点收敛、一致收敛）</p></li></ul><img src="https://pic1.imgdb.cn/item/678d3227d0e0a243d4f5b785.png" alt="image-20241030181151855" style="zoom: 33%;" /><h3 id="一致性">一致性</h3><img src="https://pic1.imgdb.cn/item/678d3227d0e0a243d4f5b786.png" alt="image-20241030181442286" style="zoom: 33%;" /><img src="https://pic1.imgdb.cn/item/678d3227d0e0a243d4f5b787.png" alt="image-20241030181503802" style="zoom:33%;" /><h2 id="SLAM-的研究方向">SLAM 的研究方向</h2><img src="https://pic1.imgdb.cn/item/678d3228d0e0a243d4f5b788.png" alt="image-20241030182054259" style="zoom: 33%;" /><img src="https://pic1.imgdb.cn/item/678d3228d0e0a243d4f5b789.png" alt="image-20241030182143296" style="zoom: 33%;" /><p><img src="https://pic1.imgdb.cn/item/678d3228d0e0a243d4f5b78a.png" alt="image-20241030182235068"></p>]]></content>
      
      
      <categories>
          
          <category> SLAM 学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>gazebo仿真环境添加激光雷达</title>
      <link href="/2024/08/01/gazebo%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83%E6%B7%BB%E5%8A%A0%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BE/"/>
      <url>/2024/08/01/gazebo%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83%E6%B7%BB%E5%8A%A0%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BE/</url>
      
        <content type="html"><![CDATA[<h1>仿真环境添加传感器（二维激光雷达）</h1><blockquote><p>前置文章：<a href="https://hins-h.github.io/2024/09/10/post-1/">gazebo无人机仿真环境配置</a></p></blockquote><h2 id="找到相应的model">找到相应的model</h2><ol><li class="lvl-4"><p>运行source .bashrc，找到GAZEBO_MODEL_PATH，进入到GAZEBO_MODEL_PATH路径</p></li></ol><p><img src="https://pic1.imgdb.cn/item/678d2af2d0e0a243d4f5b6c3.png" alt="image-20240928164435052"></p><ol start="2"><li class="lvl-3"><p>查看model目录，每个文件夹是一个model。找到iris_rplidar，这就是我们要使用的model。</p></li></ol><p><img src="https://pic1.imgdb.cn/item/678d2afad0e0a243d4f5b6c5.png" alt="image-20240928165005711"></p><ol start="3"><li class="lvl-3"><p>进入到iris_rplidar文件夹中，打开iris_rplidar.sdf文件，可以看到有若干个include标签，如lidar（雷达）、flow_cam（相机）、rplidar（二维激光雷达），说明该model包含上面三种传感器，这里我们需要注释lidar的部分，因为它会和rplidar冲突。如下图所示。</p><blockquote><p>注： <include>标签会根据<uri>标签去寻找相应的model，这个model也是在GAZEBO_MODEL_PATH路径下。进入到相应的文件夹中查看.sdf文件即为model定义文件。</p></blockquote></li></ol><p><img src="https://pic1.imgdb.cn/item/678d2affd0e0a243d4f5b6c6.png" alt="image-20240928165005711"></p><ol start="4"><li class="lvl-3"><p>进入到rplidar文件夹中，打开model.sdf文件，需要修改其中一个参数，将range标签下的min的值从0.2改成0.4。</p><blockquote><p>range标签下的min和max是指激光扫到的最近距离和最远距离，当min=0.2时，会扫到机子自身，故将其改大。</p></blockquote></li></ol><p><img src="https://pic1.imgdb.cn/item/678d2b0bd0e0a243d4f5b6c9.png" alt="image-20240928230825160"></p><h2 id="编写launch文件">编写launch文件</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;world_path&quot;</span> <span class="attr">default</span>=<span class="string">&quot;$(find px4)/Tools/simulation/gazebo/sitl_gazebo/worlds/empty.world&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;gui&quot;</span> <span class="attr">default</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;ns&quot;</span> <span class="attr">default</span>=<span class="string">&quot;/&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;model&quot;</span> <span class="attr">default</span>=<span class="string">&quot;iris_rplidar&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;fcu_url&quot;</span> <span class="attr">default</span>=<span class="string">&quot;udp://:14540@localhost:14557&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;gcs_url&quot;</span> <span class="attr">default</span>=<span class="string">&quot;&quot;</span> /&gt;</span>   <span class="comment">&lt;!-- GCS link is provided by SITL --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;tgt_system&quot;</span> <span class="attr">default</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;tgt_component&quot;</span> <span class="attr">default</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;vehicle&quot;</span> <span class="attr">default</span>=<span class="string">&quot;iris&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;use_sim_time&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;tf&quot;</span> <span class="attr">type</span>=<span class="string">&quot;static_transform_publisher&quot;</span> <span class="attr">name</span>=<span class="string">&quot;tf_2Dlidar&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">args</span>=<span class="string">&quot;0 0 0 0 0 0 base_link rplidar_link 10&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- Launch PX4 SITL --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(find px4)/launch/px4.launch&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;vehicle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg vehicle)&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Launch MavROS --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">group</span> <span class="attr">ns</span>=<span class="string">&quot;$(arg ns)&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(find mavros)/launch/node.launch&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;pluginlists_yaml&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(find mavros)/launch/px4_pluginlists.yaml&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- Need to change the config file to get the tf topic and get local position in terms of local origin --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;config_yaml&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(find simulation)/config/px4_config.yaml&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;fcu_url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg fcu_url)&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;gcs_url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg gcs_url)&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;tgt_system&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg tgt_system)&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;tgt_component&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg tgt_component)&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Launch Gazebo --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(find gazebo_ros)/launch/empty_world.launch&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;gui&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg gui)&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;world_name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg world_path)&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Spawn vehicle model --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;spawn_model&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;gazebo_ros&quot;</span> <span class="attr">type</span>=<span class="string">&quot;spawn_model&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">args</span>=<span class="string">&quot;-sdf -database $(arg model) -model $(arg vehicle)&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>上面的launch文件中发布了一个坐标系转换（tf_2Dlidar），主要是为了发布雷达的坐标系rplidar_link，这样才能在rivz中看到雷达的数据。</p></blockquote><p>启动launch文件，即可看到雷达和相机。查看雷达话题数据可以发现雷达正常运行。</p><p><img src="https://pic1.imgdb.cn/item/678d2b08d0e0a243d4f5b6c7.png" alt="image-20240928171115679"></p><p><img src="https://pic1.imgdb.cn/item/678d2b09d0e0a243d4f5b6c8.png" alt="image-20240928171936577"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>gazebo无人机仿真环境配置</title>
      <link href="/2024/08/01/gazebo%E6%97%A0%E4%BA%BA%E6%9C%BA%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/2024/08/01/gazebo%E6%97%A0%E4%BA%BA%E6%9C%BA%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1>虚拟机ubuntu20.04    gazebo无人机仿真环境配置</h1><blockquote><p>基本环境：ubuntu20.04、 ros1(noetic)</p></blockquote><h2 id="安装gaezbo">安装gaezbo</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ros-noetic-gazebo-ros</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试是否安装成功</span></span><br><span class="line">gazebo --version</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">运行gazebo</span></span><br><span class="line">gazebo  </span><br></pre></td></tr></table></figure><h2 id="安装mavros">安装mavros</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ros-noetic-mavros ros-noetic-mavros-extras</span><br></pre></td></tr></table></figure><h2 id="配置-PX4-Autopilot及编译PX4固件">配置 PX4-Autopilot及编译PX4固件</h2><h3 id="下载资源">下载资源</h3><p>将资源下载到虚拟机中并解压。将0添加PX4插件文件夹中的PX4-Autopilot1.zip解压到主目录下。完成后主目录中会有PX4-Autopilot文件夹，这就是PX4固件的工作空间。下面开始添加环境以及编译。</p><blockquote><p>相关资源下载：通过网盘分享的文件：source.zip<br>链接: <a href="https://pan.baidu.com/s/1InBqhAEsScbRCgjJ8qXEdQ?pwd=jgmi">https://pan.baidu.com/s/1InBqhAEsScbRCgjJ8qXEdQ?pwd=jgmi</a> 提取码: jgmi</p></blockquote><h3 id="编译">编译</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加python依赖</span></span><br><span class="line">sudo apt install python3-rosdep python3-rosinstall python3-rosinstall-generator python3-wstool build-essential</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在.bashrc中写入（方便知道gazebo的配置路径，后面需要用到！！）</span></span><br><span class="line">source ~/PX4-Autopilot/Tools/simulation/gazebo/setup_gazebo.bash ~/PX4-Autopilot/ ~/PX4-Autopilot/build/px4_sitl_default</span><br><span class="line">export ROS_PACKAGE_PATH=$ROS_PACKAGE_PATH:~/PX4-Autopilot</span><br><span class="line">export ROS_PACKAGE_PATH=$ROS_PACKAGE_PATH:~/PX4-Autopilot/Tools/sitl_gazebo</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入PX4工作空间</span></span><br><span class="line">cd PX4-Autopilot</span><br><span class="line">sudo bash ./Tools/setup/ubuntu.sh  # 需要等待较长时间，且需要多次运行直到无报错信息</span><br><span class="line"></span><br><span class="line">reboot</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译 PX4固件</span></span><br><span class="line">cd ~/PX4-Autopilot</span><br><span class="line">make distclean</span><br><span class="line">make px4_sitl_default gazebo</span><br></pre></td></tr></table></figure><ol><li class="lvl-3"><p><strong>常见报错：</strong></p></li></ol><ul class="lvl-0"><li class="lvl-2"><p>报错：  ModuleNotFoundError: No module named ‘menuconfig’ CMake Error at</p><p>cmake/kconfig.cmake:6 (message): kconfiglib is not installed or not in PATH</p><p>please install using “pip3 install kconfiglib”</p><p>Call Stack (most recent call first): CMakeLists.txt:174 (include)</p><p><img src="https://pic1.imgdb.cn/item/678d2b73d0e0a243d4f5b6de.png" alt="image-20240915204600813"></p><p><strong>解决方法：sudo -H python3 -m pip install kconfiglib</strong></p><p>与上面类似的报错（缺少包），直接根据提示安装对应包即可</p></li><li class="lvl-2"><p>报错：AttributeError: module ‘em’ has no attribute ‘Interpreter’</p><p><strong>解决方法：</strong></p><p><strong>sudo -H python3 -m pip uninstall em</strong></p><p><strong>sudo -H python3 -m pip install --ignore-installed empy</strong></p><p>这里可能会持续出现一个报错</p><p><img src="https://pic1.imgdb.cn/item/678d2b74d0e0a243d4f5b6df.png" alt="image-20240915204922261"></p><p><strong>解决方法：pip3 install empy==3.3.4</strong></p></li><li class="lvl-2"><p>报错：ModuleNotFoundError: No module named ‘future’、</p><p><strong>解决方法：</strong></p><p><strong>sudo -H python3 -m pip install --ignore-installed future</strong></p></li><li class="lvl-2"><p>报错：CMake Error at CMakeLists.txt:235 (project): The CMAKE_C_COMPILER:</p><p>arm-none-eabi-gcc  is not a full path and was not found in the PATH.</p><p><strong>解决方法：</strong></p><p><strong>sudo apt-get install gcc-arm-none-eabi</strong></p></li></ul><ol start="2"><li class="lvl-3"><p><strong>编译成功后终端出现PX4的字样和打开的Gazebo界面</strong></p></li></ol><p><img src="https://pic1.imgdb.cn/item/678d2b74d0e0a243d4f5b6e0.png" alt="image-20240915205622926"></p><p><img src="https://pic1.imgdb.cn/item/678d2b73d0e0a243d4f5b6dc.png" alt="image-20240915205627341"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">完成上面的编译后</span></span><br><span class="line">cd ~/PX4-Autopilot</span><br><span class="line">make px4_fmu-v5_default</span><br></pre></td></tr></table></figure><ol><li class="lvl-3"><p><strong>常见报错：</strong></p></li></ol><p><img src="https://pic1.imgdb.cn/item/678d2b75d0e0a243d4f5b6e4.png" alt="image-20241007214718028"></p><p>解决方法：sudo apt-get install gcc-arm-none-eabi</p><ol start="2"><li class="lvl-3"><p>编译成功</p></li></ol><p><img src="https://pic1.imgdb.cn/item/678d2b76d0e0a243d4f5b6e5.png" alt="image-20241007214801299"></p><h3 id="其他配置">其他配置</h3><ol><li class="lvl-3"><p>添加usr.share.GeographicLib</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入到下载的资源中的 1添加usr.share.GeographicLib 文件夹中</span></span><br><span class="line">sudo cp -r  emm2015 /usr/share/GeographicLib/</span><br><span class="line">cd egm96-5</span><br><span class="line">sudo cp -r geoids/ /usr/share/GeographicLib</span><br><span class="line">cd /emm2015</span><br><span class="line">sudo cp -r magnetic /usr/share/GeographicLib</span><br></pre></td></tr></table></figure><p>确定GeographicLib文件夹中有着三个文件夹</p><p><img src="https://pic1.imgdb.cn/item/678d2b76d0e0a243d4f5b6e6.png" alt="image-20241007214801299"></p><ol start="2"><li class="lvl-3"><p>刷新mavros环境</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入到 2刷新mavros环境 文件夹中</span></span><br><span class="line">cp install_geographiclib_datasets.sh ~/</span><br><span class="line">chmod +x install_geographiclib_datasets.sh</span><br><span class="line">sudo ./install_geographiclib_datasets.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试</span></span><br><span class="line">roslaunch px4 mavros_posix_sitl.launch</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://pic1.imgdb.cn/item/678d2b73d0e0a243d4f5b6dd.png" alt="image-20241007214801299"></p><h2 id="编写launch文件启动仿真环境">编写launch文件启动仿真环境</h2><ol><li class="lvl-3"><p>创建airhust_ws工作空间，并在工作空间内创建simulation功能包。将source ~/airhust_ws/devel/setup.bash写入.bashrc中。</p></li><li class="lvl-3"><p>在simulation下创建config文件夹，并创建文件px4_config.yaml（px4参数配置）,在使用launch文件启动仿真环境时需要用到，具体内容如下:</p></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Common configuration for PX4 autopilot</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># node:</span></span><br><span class="line"><span class="attr">startup_px4_usb_quirk:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- system plugins ---</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sys_status &amp; sys_time connection options</span></span><br><span class="line"><span class="attr">conn:</span></span><br><span class="line">  <span class="attr">heartbeat_rate:</span> <span class="number">1.0</span>    <span class="comment"># send hertbeat rate in Hertz</span></span><br><span class="line">  <span class="attr">timeout:</span> <span class="number">10.0</span>          <span class="comment"># hertbeat timeout in seconds</span></span><br><span class="line">  <span class="attr">timesync_rate:</span> <span class="number">10.0</span>    <span class="comment"># TIMESYNC rate in Hertz (feature disabled if 0.0)</span></span><br><span class="line">  <span class="attr">system_time_rate:</span> <span class="number">1.0</span>  <span class="comment"># send system time to FCU rate in Hertz (disabled if 0.0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sys_status</span></span><br><span class="line"><span class="attr">sys:</span></span><br><span class="line">  <span class="attr">min_voltage:</span> <span class="number">10.0</span>   <span class="comment"># diagnostics min voltage</span></span><br><span class="line">  <span class="attr">disable_diag:</span> <span class="literal">false</span> <span class="comment"># disable all sys_status diagnostics, except heartbeat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sys_time</span></span><br><span class="line"><span class="attr">time:</span></span><br><span class="line">  <span class="attr">time_ref_source:</span> <span class="string">&quot;fcu&quot;</span>  <span class="comment"># time_reference source</span></span><br><span class="line">  <span class="attr">timesync_mode:</span> <span class="string">MAVLINK</span></span><br><span class="line">  <span class="attr">timesync_avg_alpha:</span> <span class="number">0.6</span> <span class="comment"># timesync averaging factor</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- mavros plugins (alphabetical order) ---</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3dr_radio</span></span><br><span class="line"><span class="attr">tdr_radio:</span></span><br><span class="line">  <span class="attr">low_rssi:</span> <span class="number">40</span>  <span class="comment"># raw rssi lower level for diagnostics</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># actuator_control</span></span><br><span class="line"><span class="comment"># None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># command</span></span><br><span class="line"><span class="attr">cmd:</span></span><br><span class="line">  <span class="attr">use_comp_id_system_control:</span> <span class="literal">false</span> <span class="comment"># quirk for some old FCUs</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># dummy</span></span><br><span class="line"><span class="comment"># None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ftp</span></span><br><span class="line"><span class="comment"># None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># global_position</span></span><br><span class="line"><span class="attr">global_position:</span></span><br><span class="line">  <span class="attr">frame_id:</span> <span class="string">&quot;map&quot;</span>             <span class="comment"># origin frame</span></span><br><span class="line">  <span class="attr">child_frame_id:</span> <span class="string">&quot;base_link&quot;</span> <span class="comment"># body-fixed frame</span></span><br><span class="line">  <span class="attr">rot_covariance:</span> <span class="number">99999.0</span>   <span class="comment"># covariance for attitude?</span></span><br><span class="line">  <span class="attr">gps_uere:</span> <span class="number">1.0</span>             <span class="comment"># User Equivalent Range Error (UERE) of GPS sensor (m)</span></span><br><span class="line">  <span class="attr">use_relative_alt:</span> <span class="literal">true</span>    <span class="comment"># use relative altitude for local coordinates</span></span><br><span class="line">  <span class="attr">tf:</span></span><br><span class="line">    <span class="attr">send:</span> <span class="literal">false</span>               <span class="comment"># send TF?</span></span><br><span class="line">    <span class="attr">frame_id:</span> <span class="string">&quot;map&quot;</span>  <span class="comment"># TF frame_id</span></span><br><span class="line">    <span class="attr">global_frame_id:</span> <span class="string">&quot;earth&quot;</span>  <span class="comment"># TF earth frame_id</span></span><br><span class="line">    <span class="attr">child_frame_id:</span> <span class="string">&quot;base_link&quot;</span> <span class="comment"># TF child_frame_id</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># imu_pub</span></span><br><span class="line"><span class="attr">imu:</span></span><br><span class="line">  <span class="attr">frame_id:</span> <span class="string">&quot;base_link&quot;</span></span><br><span class="line">  <span class="comment"># need find actual values</span></span><br><span class="line">  <span class="attr">linear_acceleration_stdev:</span> <span class="number">0.0003</span></span><br><span class="line">  <span class="attr">angular_velocity_stdev:</span> <span class="number">0.0003490659</span> <span class="string">//</span> <span class="number">0.02</span> <span class="string">degrees</span></span><br><span class="line">  <span class="attr">orientation_stdev:</span> <span class="number">1.0</span></span><br><span class="line">  <span class="attr">magnetic_stdev:</span> <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># local_position</span></span><br><span class="line"><span class="attr">local_position:</span></span><br><span class="line">  <span class="attr">frame_id:</span> <span class="string">&quot;odom&quot;</span></span><br><span class="line">  <span class="attr">tf:</span></span><br><span class="line">    <span class="attr">send:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">frame_id:</span> <span class="string">&quot;odom&quot;</span></span><br><span class="line">    <span class="attr">child_frame_id:</span> <span class="string">&quot;base_link&quot;</span></span><br><span class="line">    <span class="attr">send_fcu:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># param</span></span><br><span class="line"><span class="comment"># None, used for FCU params</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rc_io</span></span><br><span class="line"><span class="comment"># None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># safety_area</span></span><br><span class="line"><span class="attr">safety_area:</span></span><br><span class="line">  <span class="attr">p1:</span> &#123;<span class="attr">x:</span>  <span class="number">1.0</span>, <span class="attr">y:</span>  <span class="number">1.0</span>, <span class="attr">z:</span>  <span class="number">1.0</span>&#125;</span><br><span class="line">  <span class="attr">p2:</span> &#123;<span class="attr">x:</span> <span class="number">-1.0</span>, <span class="attr">y:</span> <span class="number">-1.0</span>, <span class="attr">z:</span> <span class="number">-1.0</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># setpoint_accel</span></span><br><span class="line"><span class="attr">setpoint_accel:</span></span><br><span class="line">  <span class="attr">send_force:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># setpoint_attitude</span></span><br><span class="line"><span class="attr">setpoint_attitude:</span></span><br><span class="line">  <span class="attr">reverse_thrust:</span> <span class="literal">false</span>     <span class="comment"># allow reversed thrust</span></span><br><span class="line">  <span class="attr">use_quaternion:</span> <span class="literal">false</span>     <span class="comment"># enable PoseStamped topic subscriber</span></span><br><span class="line">  <span class="attr">tf:</span></span><br><span class="line">    <span class="attr">listen:</span> <span class="literal">false</span>           <span class="comment"># enable tf listener (disable topic subscribers)</span></span><br><span class="line">    <span class="attr">frame_id:</span> <span class="string">&quot;map&quot;</span></span><br><span class="line">    <span class="attr">child_frame_id:</span> <span class="string">&quot;target_attitude&quot;</span></span><br><span class="line">    <span class="attr">rate_limit:</span> <span class="number">50.0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">setpoint_raw:</span></span><br><span class="line">  <span class="attr">thrust_scaling:</span> <span class="number">1.0</span>       <span class="comment"># used in setpoint_raw attitude callback.</span></span><br><span class="line">  <span class="comment"># <span class="doctag">Note:</span> PX4 expects normalized thrust values between 0 and 1, which means that</span></span><br><span class="line">  <span class="comment"># the scaling needs to be unitary and the inputs should be 01 as well.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># setpoint_position</span></span><br><span class="line"><span class="attr">setpoint_position:</span></span><br><span class="line">  <span class="attr">tf:</span></span><br><span class="line">    <span class="attr">listen:</span> <span class="literal">false</span>           <span class="comment"># enable tf listener (disable topic subscribers)</span></span><br><span class="line">    <span class="attr">frame_id:</span> <span class="string">&quot;map&quot;</span></span><br><span class="line">    <span class="attr">child_frame_id:</span> <span class="string">&quot;target_position&quot;</span></span><br><span class="line">    <span class="attr">rate_limit:</span> <span class="number">50.0</span></span><br><span class="line">  <span class="attr">mav_frame:</span> <span class="string">LOCAL_NED</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># setpoint_velocity</span></span><br><span class="line"><span class="attr">setpoint_velocity:</span></span><br><span class="line">  <span class="attr">mav_frame:</span> <span class="string">LOCAL_NED</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># vfr_hud</span></span><br><span class="line"><span class="comment"># None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># waypoint</span></span><br><span class="line"><span class="attr">mission:</span></span><br><span class="line">  <span class="attr">pull_after_gcs:</span> <span class="literal">true</span>  <span class="comment"># update mission if gcs updates</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- mavros extras plugins (same order) ---</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># adsb</span></span><br><span class="line"><span class="comment"># None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># debug_value</span></span><br><span class="line"><span class="comment"># None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># distance_sensor</span></span><br><span class="line"><span class="comment">## Currently available orientations:</span></span><br><span class="line"><span class="comment">#    Check http://wiki.ros.org/mavros/Enumerations</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="attr">distance_sensor:</span></span><br><span class="line">  <span class="attr">hrlv_ez4_pub:</span></span><br><span class="line">    <span class="attr">id:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">frame_id:</span> <span class="string">&quot;hrlv_ez4_sonar&quot;</span></span><br><span class="line">    <span class="attr">orientation:</span> <span class="string">PITCH_270</span> <span class="comment"># RPY:&#123;0.0, 270.0, 0.0&#125; - downward-facing</span></span><br><span class="line">    <span class="attr">field_of_view:</span> <span class="number">0.0</span>  <span class="comment"># XXX TODO</span></span><br><span class="line">    <span class="attr">send_tf:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">sensor_position:</span> &#123;<span class="attr">x:</span>  <span class="number">0.0</span>, <span class="attr">y:</span>  <span class="number">0.0</span>, <span class="attr">z:</span>  <span class="number">-0.1</span>&#125;</span><br><span class="line">  <span class="attr">lidarlite_pub:</span></span><br><span class="line">    <span class="attr">id:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">frame_id:</span> <span class="string">&quot;lidarlite_laser&quot;</span></span><br><span class="line">    <span class="attr">orientation:</span> <span class="string">PITCH_270</span></span><br><span class="line">    <span class="attr">field_of_view:</span> <span class="number">0.0</span>  <span class="comment"># XXX TODO</span></span><br><span class="line">    <span class="attr">send_tf:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">sensor_position:</span> &#123;<span class="attr">x:</span>  <span class="number">0.0</span>, <span class="attr">y:</span>  <span class="number">0.0</span>, <span class="attr">z:</span>  <span class="number">-0.1</span>&#125;</span><br><span class="line">  <span class="attr">sonar_1_sub:</span></span><br><span class="line">    <span class="attr">subscriber:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">id:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">orientation:</span> <span class="string">PITCH_270</span></span><br><span class="line">  <span class="attr">laser_1_sub:</span></span><br><span class="line">    <span class="attr">subscriber:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">id:</span> <span class="number">3</span></span><br><span class="line">    <span class="attr">orientation:</span> <span class="string">PITCH_270</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># image_pub</span></span><br><span class="line"><span class="attr">image:</span></span><br><span class="line">  <span class="attr">frame_id:</span> <span class="string">&quot;px4flow&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fake_gps</span></span><br><span class="line"><span class="attr">fake_gps:</span></span><br><span class="line">  <span class="comment"># select data source</span></span><br><span class="line">  <span class="attr">use_mocap:</span> <span class="literal">true</span>         <span class="comment"># ~mocap/pose</span></span><br><span class="line">  <span class="attr">mocap_transform:</span> <span class="literal">true</span>   <span class="comment"># ~mocap/tf instead of pose</span></span><br><span class="line">  <span class="attr">use_vision:</span> <span class="literal">false</span>       <span class="comment"># ~vision (pose)</span></span><br><span class="line">  <span class="comment"># origin (default: Zürich)</span></span><br><span class="line">  <span class="attr">geo_origin:</span></span><br><span class="line">    <span class="attr">lat:</span> <span class="number">47.3667</span>          <span class="comment"># latitude [degrees]</span></span><br><span class="line">    <span class="attr">lon:</span> <span class="number">8.5500</span>           <span class="comment"># longitude [degrees]</span></span><br><span class="line">    <span class="attr">alt:</span> <span class="number">408.0</span>            <span class="comment"># altitude (height over the WGS-84 ellipsoid) [meters]</span></span><br><span class="line">  <span class="attr">eph:</span> <span class="number">2.0</span></span><br><span class="line">  <span class="attr">epv:</span> <span class="number">2.0</span></span><br><span class="line">  <span class="attr">satellites_visible:</span> <span class="number">5</span>   <span class="comment"># virtual number of visible satellites</span></span><br><span class="line">  <span class="attr">fix_type:</span> <span class="number">3</span>             <span class="comment"># type of GPS fix (default: 3D)</span></span><br><span class="line">  <span class="attr">tf:</span></span><br><span class="line">    <span class="attr">listen:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">send:</span> <span class="literal">false</span>           <span class="comment"># send TF?</span></span><br><span class="line">    <span class="attr">frame_id:</span> <span class="string">&quot;map&quot;</span>       <span class="comment"># TF frame_id</span></span><br><span class="line">    <span class="attr">child_frame_id:</span> <span class="string">&quot;fix&quot;</span> <span class="comment"># TF child_frame_id</span></span><br><span class="line">    <span class="attr">rate_limit:</span> <span class="number">10.0</span>      <span class="comment"># TF rate</span></span><br><span class="line">  <span class="attr">gps_rate:</span> <span class="number">5.0</span>           <span class="comment"># GPS data publishing rate</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># landing_target</span></span><br><span class="line"><span class="attr">landing_target:</span></span><br><span class="line">  <span class="attr">listen_lt:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">mav_frame:</span> <span class="string">&quot;LOCAL_NED&quot;</span></span><br><span class="line">  <span class="attr">land_target_type:</span> <span class="string">&quot;VISION_FIDUCIAL&quot;</span></span><br><span class="line">  <span class="attr">image:</span></span><br><span class="line">    <span class="attr">width:</span> <span class="number">640</span>            <span class="comment"># [pixels]</span></span><br><span class="line">    <span class="attr">height:</span> <span class="number">480</span></span><br><span class="line">  <span class="attr">camera:</span></span><br><span class="line">    <span class="attr">fov_x:</span> <span class="number">2.0071286398</span>   <span class="comment"># default: 115 [degrees]</span></span><br><span class="line">    <span class="attr">fov_y:</span> <span class="number">2.0071286398</span></span><br><span class="line">  <span class="attr">tf:</span></span><br><span class="line">    <span class="attr">send:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">listen:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">frame_id:</span> <span class="string">&quot;landing_target&quot;</span></span><br><span class="line">    <span class="attr">child_frame_id:</span> <span class="string">&quot;camera_center&quot;</span></span><br><span class="line">    <span class="attr">rate_limit:</span> <span class="number">10.0</span></span><br><span class="line">  <span class="attr">target_size:</span> &#123;<span class="attr">x:</span>  <span class="number">0.3</span>, <span class="attr">y:</span>  <span class="number">0.3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># mocap_pose_estimate</span></span><br><span class="line"><span class="attr">mocap:</span></span><br><span class="line">  <span class="comment"># select mocap source</span></span><br><span class="line">  <span class="attr">use_tf:</span> <span class="literal">false</span>   <span class="comment"># ~mocap/tf</span></span><br><span class="line">  <span class="attr">use_pose:</span> <span class="literal">true</span>  <span class="comment"># ~mocap/pose</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># odom</span></span><br><span class="line"><span class="attr">odometry:</span></span><br><span class="line">  <span class="attr">fcu:</span></span><br><span class="line">    <span class="attr">odom_parent_id_des:</span> <span class="string">&quot;map&quot;</span>    <span class="comment"># desired parent frame rotation of the FCU&#x27;s odometry</span></span><br><span class="line">    <span class="attr">odom_child_id_des:</span> <span class="string">&quot;base_link&quot;</span>    <span class="comment"># desired child frame rotation of the FCU&#x27;s odometry</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># px4flow</span></span><br><span class="line"><span class="attr">px4flow:</span></span><br><span class="line">  <span class="attr">frame_id:</span> <span class="string">&quot;px4flow&quot;</span></span><br><span class="line">  <span class="attr">ranger_fov:</span> <span class="number">0.118682</span>      <span class="comment"># 6.8 degrees at 5 meters, 31 degrees at 1 meter</span></span><br><span class="line">  <span class="attr">ranger_min_range:</span> <span class="number">0.3</span>     <span class="comment"># meters</span></span><br><span class="line">  <span class="attr">ranger_max_range:</span> <span class="number">5.0</span>     <span class="comment"># meters</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># vision_pose_estimate</span></span><br><span class="line"><span class="attr">vision_pose:</span></span><br><span class="line">  <span class="attr">tf:</span></span><br><span class="line">    <span class="attr">listen:</span> <span class="literal">false</span>           <span class="comment"># enable tf listener (disable topic subscribers)</span></span><br><span class="line">    <span class="attr">frame_id:</span> <span class="string">&quot;odom&quot;</span></span><br><span class="line">    <span class="attr">child_frame_id:</span> <span class="string">&quot;vision_estimate&quot;</span></span><br><span class="line">    <span class="attr">rate_limit:</span> <span class="number">10.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># vision_speed_estimate</span></span><br><span class="line"><span class="attr">vision_speed:</span></span><br><span class="line">  <span class="attr">listen_twist:</span> <span class="literal">true</span>    <span class="comment"># enable listen to twist topic, else listen to vec3d topic</span></span><br><span class="line">  <span class="attr">twist_cov:</span> <span class="literal">true</span>       <span class="comment"># enable listen to twist with covariance topic</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># vibration</span></span><br><span class="line"><span class="attr">vibration:</span></span><br><span class="line">  <span class="attr">frame_id:</span> <span class="string">&quot;base_link&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># wheel_odometry</span></span><br><span class="line"><span class="attr">wheel_odometry:</span></span><br><span class="line">  <span class="attr">count:</span> <span class="number">2</span>           <span class="comment"># number of wheels to compute odometry</span></span><br><span class="line">  <span class="attr">use_rpm:</span> <span class="literal">false</span>     <span class="comment"># use wheel&#x27;s RPM instead of cumulative distance to compute odometry</span></span><br><span class="line">  <span class="attr">wheel0:</span> &#123;<span class="attr">x:</span> <span class="number">0.0</span>, <span class="attr">y:</span> <span class="number">-0.15</span>, <span class="attr">radius:</span> <span class="number">0.05</span>&#125; <span class="comment"># x-, y-offset (m,NED) and radius (m)</span></span><br><span class="line">  <span class="attr">wheel1:</span> &#123;<span class="attr">x:</span> <span class="number">0.0</span>, <span class="attr">y:</span>  <span class="number">0.15</span>, <span class="attr">radius:</span> <span class="number">0.05</span>&#125; <span class="comment"># x-, y-offset (m,NED) and radius (m)</span></span><br><span class="line">  <span class="attr">send_raw:</span> <span class="literal">true</span>              <span class="comment"># send wheel&#x27;s RPM and cumulative distance (~/wheel_odometry/rpm, ~/wheel_odometry/distance)</span></span><br><span class="line">  <span class="attr">send_twist:</span> <span class="literal">false</span>           <span class="comment"># send geometry_msgs/TwistWithCovarianceStamped instead of nav_msgs/Odometry</span></span><br><span class="line">  <span class="attr">frame_id:</span> <span class="string">&quot;odom&quot;</span>             <span class="comment"># origin frame</span></span><br><span class="line">  <span class="attr">child_frame_id:</span> <span class="string">&quot;base_link&quot;</span> <span class="comment"># body-fixed frame</span></span><br><span class="line">  <span class="attr">vel_error:</span> <span class="number">0.1</span>              <span class="comment"># wheel velocity measurement error 1-std (m/s)</span></span><br><span class="line">  <span class="attr">tf:</span></span><br><span class="line">    <span class="attr">send:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">frame_id:</span> <span class="string">&quot;odom&quot;</span></span><br><span class="line">    <span class="attr">child_frame_id:</span> <span class="string">&quot;base_link&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># vim:set ts=2 sw=2 et:</span></span><br></pre></td></tr></table></figure><ol start="3"><li class="lvl-3"><p>在simulation下创建launch文件夹，并创建iris.launch文件</p></li></ol><p>​需要注意的点：</p><ul class="lvl-0"><li class="lvl-2"><p>world_path参数：gazebo启动寻找的地图文件，world_path需要自己指定路径；</p></li><li class="lvl-2"><p>model参数：gazebo启动寻找的model文件。model的路径是GAZEBO_MODEL_PATH，该路径的值在source .bashrc之后能看到（在第6步安装px4的时候将几行命令写入.bashrc就是为了寻找model路径）。这里model的路径是~/PX4-Autopilot/Tools/simulation/gazebo/sitl_gazebo/models。px4官方包已经自带了一些无人机及相关传感器的model，后序如果想自己添加model，将相关文件放到GAZEBO_MODEL_PATH路径下即可被gazebo找到。</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;world_path&quot;</span> <span class="attr">default</span>=<span class="string">&quot;$(find px4)/Tools/simulation/gazebo/sitl_gazebo/worlds/empty.world&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;gui&quot;</span> <span class="attr">default</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;ns&quot;</span> <span class="attr">default</span>=<span class="string">&quot;/&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;model&quot;</span> <span class="attr">default</span>=<span class="string">&quot;iris&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;fcu_url&quot;</span> <span class="attr">default</span>=<span class="string">&quot;udp://:14540@localhost:14557&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;gcs_url&quot;</span> <span class="attr">default</span>=<span class="string">&quot;&quot;</span> /&gt;</span>   <span class="comment">&lt;!-- GCS link is provided by SITL --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;tgt_system&quot;</span> <span class="attr">default</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;tgt_component&quot;</span> <span class="attr">default</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;vehicle&quot;</span> <span class="attr">default</span>=<span class="string">&quot;iris&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;use_sim_time&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">           </span><br><span class="line">    <span class="comment">&lt;!-- Launch PX4 SITL --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(find px4)/launch/px4.launch&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;vehicle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg vehicle)&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Launch MavROS --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">group</span> <span class="attr">ns</span>=<span class="string">&quot;$(arg ns)&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(find mavros)/launch/node.launch&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;pluginlists_yaml&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(find mavros)/launch/px4_pluginlists.yaml&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- Need to change the config file to get the tf topic and get local position in terms of local origin --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;config_yaml&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(find simulation)/config/px4_config.yaml&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;fcu_url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg fcu_url)&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;gcs_url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg gcs_url)&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;tgt_system&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg tgt_system)&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;tgt_component&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg tgt_component)&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Launch Gazebo --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(find gazebo_ros)/launch/empty_world.launch&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;gui&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg gui)&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;world_name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg world_path)&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Spawn vehicle model --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;spawn_model&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;gazebo_ros&quot;</span> <span class="attr">type</span>=<span class="string">&quot;spawn_model&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">args</span>=<span class="string">&quot;-sdf -database $(arg model) -model $(arg vehicle)&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li class="lvl-3"><p>回到airhust_ws目录下catkin_make</p></li><li class="lvl-3"><p>运行以下命令即可</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch simulation iris.launch</span><br></pre></td></tr></table></figure><p>正常运行显示如下：</p><p><img src="https://pic1.imgdb.cn/item/678d2b73d0e0a243d4f5b6db.png" alt="image-20241007220008340"></p><h2 id="下载地面站">下载地面站</h2><p>​按照官网教程下载即可</p><p>​<a href="https://docs.qgroundcontrol.com/master/en/qgc-user-guide/getting_started/download_and_install.html">https://docs.qgroundcontrol.com/master/en/qgc-user-guide/getting_started/download_and_install.html</a></p><ul class="lvl-0"><li class="lvl-2"><p>地面站控制无人机起飞</p></li></ul><ol><li class="lvl-3"><p>打开qgc地面站，点击起飞</p></li></ol><p><img src="https://pic1.imgdb.cn/item/678d2b75d0e0a243d4f5b6e2.png" alt="image-20240918113142192"></p><ol start="2"><li class="lvl-3"><p>滑动解锁，无人机起飞升空</p></li></ol><p><img src="https://pic1.imgdb.cn/item/678d2b75d0e0a243d4f5b6e3.png" alt="image-20240918113240369"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PX4相关硬件模块</title>
      <link href="/2024/01/11/PX4%E7%9B%B8%E5%85%B3%E7%A1%AC%E4%BB%B6%E6%A8%A1%E5%9D%97/"/>
      <url>/2024/01/11/PX4%E7%9B%B8%E5%85%B3%E7%A1%AC%E4%BB%B6%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h1>PX4相关硬件模块</h1><blockquote><p>相关视频链接：<a href="https://www.bilibili.com/cheese/play/ep566011?csource=common_myclass_purchasedlecture_null&amp;spm_id_from=333.874.selfDef.mine_paid_list">新手必学！开源无人机飞控系统PX4开发入门_哔哩哔哩_bilibili</a></p></blockquote><h2 id="模块分类">模块分类</h2><ul class="lvl-0"><li class="lvl-2"><p>动力系统：螺旋桨、电机、电调、电源等</p></li><li class="lvl-2"><p>控制系统：核心是以 PIXHAWK、赫星等核心运算和处理等功能的飞控板子。此外包括遥控器（接受机）、数传、图传等。其中数传和图传是在实现自主飞行时将作为图片输入到机载计算机的信息源头，某种意义可以理解为控制输入。</p></li><li class="lvl-2"><p>机架模块：由机身、起落架组成</p></li><li class="lvl-2"><p>外载模块：外载计算机（TX2、树莓派、NANO、NX等）、摄像头、雷达等</p></li><li class="lvl-2"><p>其他：减震、降噪、充电器、BB响等</p></li></ul><h2 id="PIXHAWK硬件V2-4-8-和-V4">PIXHAWK硬件V2.4.8 和 V4</h2><h3 id="V2-4-8">V2.4.8</h3><p><img src="https://pic1.imgdb.cn/item/678d2caad0e0a243d4f5b6fd.png" alt="image-20241029023552410" style="zoom:50%;" /> <img src="https://pic1.imgdb.cn/item/678d2cabd0e0a243d4f5b6fe.png" alt="image-20241029023614944" style="zoom: 50%;" /></p><h4 id="V2-4-8-实际连接飞机的接线图">V2.4.8 实际连接飞机的接线图</h4><img src="https://pic1.imgdb.cn/item/678d2cabd0e0a243d4f5b6ff.png" alt="image-20241029023729266" style="zoom: 50%;" /><h4 id="V2-4-8引脚">V2.4.8引脚</h4><h5 id="接口引脚">接口引脚</h5><img src="https://pic1.imgdb.cn/item/678d2cacd0e0a243d4f5b704.png" alt="img" style="zoom: 67%;" /><img src="https://pic1.imgdb.cn/item/678d2cacd0e0a243d4f5b706.png" alt="img" style="zoom: 67%;" /><h5 id="输出引脚">输出引脚</h5><img src="https://pic1.imgdb.cn/item/678d2cacd0e0a243d4f5b705.png" alt="img" style="zoom:67%;" /><p>​正面向上，从左开始1-6是辅助通道，可以在地面站中添加。例如额外加入舵机实现多功能。7-14是主通道，最后是遥控器。</p><h4 id="主从处理器件">主从处理器件</h4><p>​Pixhawk 硬件整体分为了 PX4FMU 和 PX4IO。</p><ol><li class="lvl-3"><p>PX4FMU 主处理器件：STM32 f427。主要是用于数据获取、计算、控制等核心代码。</p></li><li class="lvl-3"><p>PX4IO 从处理器件：STM32 f100:8路主PWM。主要用于输出电机、电调、接收机等。</p></li></ol><blockquote><p>主从处理器使用串口通信</p></blockquote><h4 id="Bootloader操作系统">Bootloader操作系统</h4><p>​操作系统，分别在主从处理器中烧入。其作用是用于连接IMU等硬件和PX4、APM固件。</p><h3 id="PIXHAWK-V4">PIXHAWK V4</h3><img src="https://pic1.imgdb.cn/item/678d2cabd0e0a243d4f5b700.png" alt="image-20241029025810369" style="zoom:50%;" /><h4 id="实际连接飞机接线图">实际连接飞机接线图</h4><p><img src="https://pic1.imgdb.cn/item/678d2cabd0e0a243d4f5b701.png" alt="image-20241029025839490"></p><h2 id="IMU-惯性测量单元（姿态数据源头）">IMU 惯性测量单元（姿态数据源头）</h2><h3 id="概念">概念</h3><p>Inertial Measurement Unit首字母的缩写，即惯性测量单元。</p><h3 id="组成">组成</h3><p>主要由加速度计、陀螺仪、磁力计三部分组成。</p><h3 id="作用">作用</h3><p>​测量当前载体的姿态信息（姿态解算），从而与期望的姿态进行差值计算，实现姿态控制。</p><p>​姿态：三维姿态包括 横滚roll、俯仰pitch、偏航yaw</p><img src="https://pic1.imgdb.cn/item/678d2cacd0e0a243d4f5b703.png" alt="image-20241029100551111" style="zoom:50%;" /><ul class="lvl-0"><li class="lvl-2"><p><strong>陀螺仪</strong>：直接可以得到角速度，积分即为角度。但存在零点漂移和温漂。校准时，是静止一段时间获得平均值。</p></li><li class="lvl-2"><p><strong>加速度计</strong>：测量在平面的加速度即roll 和 pitch（对振动很敏感、减震）。校准时，进行六面校准，利用每一轴的重力加速度来参考标定。</p></li><li class="lvl-2"><p><strong>磁力计</strong>：测量可得到载体的方向信息，即yaw。校准也是六面进行。</p></li></ul><h2 id="其他传感器">其他传感器</h2><ul class="lvl-0"><li class="lvl-2"><p><strong>GPS</strong>：定位作用</p></li><li class="lvl-2"><p><strong>激光测距</strong>：测量距离作用（高度）（TFmini、PX4flow）</p></li><li class="lvl-2"><p><strong>气压计</strong>：高度测量作用。气压计通过不同海拔高度的气压不同，压电式气压计反馈得到高度数值。</p></li><li class="lvl-2"><p><strong>MOCAP</strong>：三维动作捕捉，<strong>室内</strong>三维定位</p></li><li class="lvl-2"><p><strong>UWB</strong>：超宽带（Ultra Wide Band），<strong>室内</strong>三维定位</p></li><li class="lvl-2"><p><strong>RTK</strong>：测RTK（Real - time kinematic，实时动态）载波相位差分技术，是实时处理两个测量站载波相位观测量的差分方法，将基准站采集的载波相位发给用户接收机，进行求差解算坐标。这是一种新的常用的卫星定位测量方法，<strong>室外</strong>三维定位。</p></li><li class="lvl-2"><p>雷达：测距</p></li><li class="lvl-2"><p>视觉（摄像头）：跟随、避障</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PID算法</title>
      <link href="/2023/12/11/PID%E7%AE%97%E6%B3%95/"/>
      <url>/2023/12/11/PID%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1>PID算法</h1><h2 id="PID算法一般形式">PID算法一般形式</h2><p><img src="https://pic1.imgdb.cn/item/678d2c4cd0e0a243d4f5b6f5.png" alt="image-20241030150041067"></p><h2 id="基本形式">基本形式</h2><p>​PID 算法的流程主要是<strong>通过误差信号控制被控量</strong>，而控制器是比例、积分、微分三个环节的加和。这里规定（t时刻）：</p><ul class="lvl-0"><li class="lvl-2"><p>输入量为 rin(t)</p></li><li class="lvl-2"><p>输出量为 rout(t)</p></li><li class="lvl-2"><p>偏差量为 err(t) = rin(t) - rout(t)</p></li></ul><p>​PID 的控制规律为</p><p>​<img src="https://pic1.imgdb.cn/item/678d2c4cd0e0a243d4f5b6f6.png" alt="image-20241030150819617" style="zoom: 67%;" /></p><p>​对比例、积分、微分环节的解释：</p><ul class="lvl-0"><li class="lvl-2"><p>如果偏差为0，则比例环节不起作用，只有<strong>存在偏差时</strong>才起作用。</p></li><li class="lvl-2"><p>积分环节主要是用来<strong>消除静差</strong>（系统稳定后输出值和设定值之间的差值），积分环节实际上就是偏差累计的过程，把累计的误差加到原有系统上以抵消系统造成的静差。</p></li><li class="lvl-2"><p>微分环节反应了偏差信号的变化规律，根据偏差信号的变化趋势来进行<strong>超前调节</strong>，从而增加系统快速性。</p></li></ul><h2 id="连续系统离散化（位置式）">连续系统离散化（位置式）</h2><p>​假设采样间隔为T，在第 K T 时刻：</p><ul class="lvl-0"><li class="lvl-2"><p>偏差： err(K) = rin(K) - rout(K)</p></li><li class="lvl-2"><p>积分：err(K) + err(K+1) + ···  （简化为用和来表示）</p></li><li class="lvl-2"><p>微分：(err(K) - err(K-1)) / T （简化为斜率表示）</p></li></ul><p>​故 PID 离散表示形式：</p><img src="https://pic1.imgdb.cn/item/678d2c4dd0e0a243d4f5b6f7.png" alt="image-20241030151759514" style="zoom: 50%;" /><p>​可表示为：</p><img src="https://pic1.imgdb.cn/item/678d2c4bd0e0a243d4f5b6f1.png" alt="image-20241030152247443" style="zoom:50%;" /><h2 id="连续系统离散化（增量式）">连续系统离散化（增量式）</h2><p>​由位置式公式可以得到</p><p>​<img src="https://pic1.imgdb.cn/item/678d2c4bd0e0a243d4f5b6f2.png" alt="image-20241030152553675" style="zoom: 33%;" /></p><p>​作差可以得到离散化 PID 的增量式表达方式</p><p>​<img src="https://pic1.imgdb.cn/item/678d2c4bd0e0a243d4f5b6f3.jpg" alt="img"></p><p>​需要注意的是最终输出结果为</p><p>​<img src="https://pic1.imgdb.cn/item/678d2c4cd0e0a243d4f5b6f4.jpg" alt="img" style="zoom:80%;" /></p><h2 id="代码实现">代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PID</span> &#123;</span><br><span class="line">  <span class="type">float</span> SetSpeed;</span><br><span class="line">  <span class="type">float</span> ActualSpeed;</span><br><span class="line">  <span class="type">float</span> err;</span><br><span class="line">  <span class="type">float</span> err_last; <span class="comment">// 前一次偏差</span></span><br><span class="line">  <span class="type">float</span> Kp, Ki, Kd;</span><br><span class="line">  <span class="type">float</span> voltage; <span class="comment">// 电压(控制执行器的变量)</span></span><br><span class="line">  <span class="type">float</span> integral;  <span class="comment">// 积分</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">PID</span>(<span class="type">float</span> Kp, <span class="type">float</span> Ki, <span class="type">float</span> Kd):<span class="built_in">SetSpeed</span>(<span class="number">0</span>), <span class="built_in">ActualSpeed</span>(<span class="number">0</span>), <span class="built_in">err</span>(<span class="number">0</span>), <span class="built_in">err_last</span>(<span class="number">0</span>), <span class="built_in">Kp</span>(Kp), <span class="built_in">Ki</span>(Ki), <span class="built_in">Kd</span>(Kd), <span class="built_in">voltage</span>(<span class="number">0</span>), <span class="built_in">integral</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">float</span> <span class="title">PID_realize</span><span class="params">(<span class="type">float</span> speed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;SetSpeed = speed;</span><br><span class="line">    <span class="keyword">this</span>-&gt;err = <span class="keyword">this</span>-&gt;SetSpeed - <span class="keyword">this</span>-&gt;ActualSpeed;</span><br><span class="line">    <span class="keyword">this</span>-&gt;integral += <span class="keyword">this</span>-&gt;err;</span><br><span class="line">    <span class="keyword">this</span>-&gt;voltage = <span class="keyword">this</span>-&gt;Kp * <span class="keyword">this</span>-&gt;err + <span class="keyword">this</span>-&gt;Ki * <span class="keyword">this</span>-&gt;integral + <span class="keyword">this</span>-&gt;Kd * (<span class="keyword">this</span>-&gt;err - <span class="keyword">this</span>-&gt;err_last); <span class="comment">// 增量式</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;err_last = <span class="keyword">this</span>-&gt;err;</span><br><span class="line">    <span class="keyword">this</span>-&gt;ActualSpeed = <span class="keyword">this</span>-&gt;voltage * <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;ActualSpeed;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;system begin&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="function">PID <span class="title">pid</span><span class="params">(<span class="number">0.2</span>, <span class="number">0.15</span>, <span class="number">0.2</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) </span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; pid.<span class="built_in">PID_realize</span>(<span class="number">200.0</span>) &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
